digraph call_graph {
  rankdir=LR;
  node [shape=box, style=filled, fillcolor=lightblue, fontname=Helvetica];
  edge [color=gray];

  subgraph cluster_0 {
    label = "/home/lacra/git_repos/refinedrust-dev/case_studies/minivec/src";
    style=filled;
    color=lightgrey;
    fontname=Helvetica;
    "rust-analyzer cargo minivec 0.1.0 rrptr/dangling()." [label="dangling", tooltip="    pub fn dangling<T>() -> *mut T {         NonNull::dangling().as_ptr()     }"]
    "rust-analyzer cargo minivec 0.1.0 rrptr/const_add()." [label="const_add", tooltip="    pub unsafe fn const_add<T>(ptr: *const T, count: usize) -> *const T  {         ptr.add(count)     }"]
    "rust-analyzer cargo minivec 0.1.0 client/get_mut_client()." [label="get_mut_client", tooltip="fn get_mut_client()  {      // We have desugared this, as the macro uses parts of Rust our frontend does not support yet.     //let mut x = vec![100, 200, 300];     let mut x = Vec::new();     x.push(..."]
    "rust-analyzer cargo minivec 0.1.0 impl#[`Vec<T>`]new()." [label="new", tooltip="    pub fn new() -> Self  {         Vec {             buf: RawVec::new(),             len: 0,         }     }"]
    "rust-analyzer cargo minivec 0.1.0 rralloc/check_array_layoutable()." [label="check_array_layoutable", tooltip="    pub fn check_array_layoutable<T>(len: usize) -> bool  {         let layout = Layout::array::<T>(len);         layout.is_ok()     }"]
    "rust-analyzer cargo minivec 0.1.0 rrptr/const_offset()." [label="const_offset", tooltip="    pub unsafe fn const_offset<T>(ptr: *const T, count: isize) -> *const T  {         ptr.offset(count)     }"]
    "rust-analyzer cargo minivec 0.1.0 rralloc/realloc_array()." [label="realloc_array", tooltip="    pub unsafe fn realloc_array<T>(old_len: usize, ptr: *mut T, new_len: usize) -> *mut T  {         assert!(new_len > 0);         // fine: checks that size is ≤ MaxInt isize         let old_layout ..."]
    "rust-analyzer cargo minivec 0.1.0 rrptr/mut_offset()." [label="mut_offset", tooltip="    pub unsafe fn mut_offset<T>(ptr: *mut T, count: isize) -> *mut T  {         ptr.offset(count)     }"]
    "rust-analyzer cargo minivec 0.1.0 rrptr/mut_add()." [label="mut_add", tooltip="    pub unsafe fn mut_add<T>(ptr: *mut T, count: usize) -> *mut T  {         ptr.add(count)     }"]
    "rust-analyzer cargo minivec 0.1.0 impl#[`RawVec<T>`]new()." [label="new", tooltip="    pub fn new() -> Self  {         // !0 is usize::MAX. This branch should be stripped at compile time.         let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };          // `NonNull::dangling..."]
    "rust-analyzer cargo minivec 0.1.0 rralloc/alloc_array()." [label="alloc_array", tooltip="    pub unsafe fn alloc_array<T>(len: usize) -> *mut T  {         assert!(len > 0);         // checks that size is ≤ MaxInt isize         let ly = Layout::array::<T>(len).unwrap();          // will ..."]
    "rust-analyzer cargo minivec 0.1.0 rralloc/dealloc_array()." [label="dealloc_array", tooltip="    pub unsafe fn dealloc_array<T>(len: usize, ptr: *mut T)  {         alloc::dealloc(ptr as *mut u8, Layout::array::<T>(len).unwrap());     }"]
  }

  "rust-analyzer cargo minivec 0.1.0 client/get_mut_client()." -> "rust-analyzer cargo minivec 0.1.0 impl#[`Vec<T>`]new()."
  "rust-analyzer cargo minivec 0.1.0 impl#[`Vec<T>`]new()." -> "rust-analyzer cargo minivec 0.1.0 impl#[`RawVec<T>`]new()."
  "rust-analyzer cargo minivec 0.1.0 impl#[`Vec<T>`]new()." -> "rust-analyzer cargo minivec 0.1.0 rrptr/mut_add()."
  "rust-analyzer cargo minivec 0.1.0 impl#[`RawVec<T>`]new()." -> "rust-analyzer cargo minivec 0.1.0 rralloc/alloc_array()."
  "rust-analyzer cargo minivec 0.1.0 impl#[`RawVec<T>`]new()." -> "rust-analyzer cargo minivec 0.1.0 rralloc/realloc_array()."
  "rust-analyzer cargo minivec 0.1.0 impl#[`RawVec<T>`]new()." -> "rust-analyzer cargo minivec 0.1.0 rralloc/check_array_layoutable()."
  "rust-analyzer cargo minivec 0.1.0 impl#[`RawVec<T>`]new()." -> "rust-analyzer cargo minivec 0.1.0 rrptr/dangling()."
}
