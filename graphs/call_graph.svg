<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="2968pt" height="188pt"
 viewBox="0.00 0.00 2968.13 188.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-184 2964.13,-184 2964.13,4 -4,4"/>
<!-- main -->
<g id="node1" class="node">
<title>main</title>
<g id="a_node1"><a xlink:title="{&#10; &#160;&#160;&#160;basic_quicksort_demo();&#10; &#160;&#160;&#160;functional_quicksort_demo();&#10;}">
<ellipse fill="none" stroke="black" cx="244.44" cy="-162" rx="33.6" ry="18"/>
<text text-anchor="middle" x="244.44" y="-158.3" font-family="Times,serif" font-size="14.00">main</text>
</a>
</g>
</g>
<!-- basic_quicksort_demo -->
<g id="node6" class="node">
<title>basic_quicksort_demo</title>
<g id="a_node6"><a xlink:title="{&#10; &#160;&#160;&#160;let mut numbers = vec![10, 7, 8, 9, 1, 5];&#10; &#160;&#160;&#160;println!(&quot;Unsorted array: {:?}&quot;, numbers);&#10; &#160;&#160;&#160;quicksort(&amp;mut numbers);&#10; &#160;&#160;&#160;println!(&quot;Sorted array: {:?}&quot;, numbers);&#10; &#160;&#160;&#160;let mut words = vec![&quot;banana&quot;, &quot;apple&quot;, &quot;cherry&quot;, &quot;date&quot;, &quot;elderberry&quot;];&#10; &#160;&#160;&#160;println!(&quot;Unsorted words: {:?}&quot;, words);&#10; &#160;&#160;&#160;quicksort(&amp;mut words);&#10; &#160;&#160;&#160;println!(&quot;Sorted words: {:?}&quot;, words);&#10;}">
<ellipse fill="none" stroke="black" cx="112.44" cy="-90" rx="112.38" ry="18"/>
<text text-anchor="middle" x="112.44" y="-86.3" font-family="Times,serif" font-size="14.00">basic_quicksort_demo</text>
</a>
</g>
</g>
<!-- main&#45;&gt;basic_quicksort_demo -->
<g id="edge2" class="edge">
<title>main&#45;&gt;basic_quicksort_demo</title>
<path fill="none" stroke="black" d="M221.45,-148.81C202.49,-138.75 175.15,-124.26 152.59,-112.29"/>
<polygon fill="black" stroke="black" points="154.05,-109.1 143.58,-107.51 150.77,-115.29 154.05,-109.1"/>
</g>
<!-- functional_quicksort_demo -->
<g id="node7" class="node">
<title>functional_quicksort_demo</title>
<g id="a_node7"><a xlink:title="{&#10; &#160;&#160;&#160;use functional_quicksort::*;&#10; &#160;&#160;&#160;println!(&quot;&#10;&#45;&#45;&#45; Functional Quicksort Demo &#45;&#45;&#45;&quot;);&#10; &#160;&#160;&#160;let numbers = vec![10, 7, 8, 9, 1, 5];&#10; &#160;&#160;&#160;println!(&quot;Original numbers: {:?}&quot;, numbers);&#10; &#160;&#160;&#160;let sorted_numbers = quicksort_functional_ord(&amp;numbers);&#10; &#160;&#160;&#160;println!(&quot;Sorted numbers: {:?}&quot;, sorted_numbers);&#10; &#160;&#160;&#160;println!(&quot;Original numbers(unchanged): {:?}&quot;, numbers);&#10; &#160;&#160;&#160;let sorted_desc = quicksort_functional(&amp;numbers, |a, b| b.cmp(a));&#10; &#160;&#160;&#160;println!(&quot;Sorted in descending order: {:?}&quot;, sorted_desc);&#10; &#160;&#160;&#160;println!(&quot;&#10;Transformation example:&quot;);&#10; &#160;&#160;&#160;let people = vec![&#10; &#160;&#160;&#160;&#160;&#160;&#160;(&quot;Alice&quot;, 29),(&quot;Bob&quot;, 31),(&quot;Charlie&quot;, 27),(&quot;Diana&quot;, 31),(&quot;Eva&quot;, 25),&#10; &#160;&#160;&#160;];&#10; &#160;&#160;&#160;let sorted_ages = transform_and_sort(&amp;people, |p| p.1, |a, b| a.cmp(b));&#10; &#160;&#160;&#160;println!(&quot;Ages sorted: {:?}&quot;, sorted_ages);&#10; &#160;&#160;&#160;let sorted_names = transform_and_sort(&amp;people, |p| p.0.to_string(), |a, b| a.cmp(b));&#10; &#160;&#160;&#160;println!(&quot;Names sorted: {:?}&quot;, sorted_names);&#10; &#160;&#160;&#160;println!(&quot;&#10;Word frequency analysis:&quot;);&#10; &#160;&#160;&#160;let text = &quot;Rust is a multi&#45;paradigm programming language focused on performance and safety, \n &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;especially safe concurrency.Rust is syntactically similar to C++, but provides \n &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;memory safety without using garbage collection.Rust was originally designed by \n &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Graydon Hoare at Mozilla Research, with contributions from Dave Herman, Brendan Eich, \n &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;and others.The designers refined the language while writing the Servo layout or \n &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;browser engine, and the Rust compiler.The compiler is free and open&#45;source software \n &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dual&#45;licensed under the MIT License and Apache License 2.0.&quot;;&#10; &#160;&#160;&#160;let word_frequencies = word_frequency_analysis(text);&#10; &#160;&#160;&#160;println!(&quot;Top 10 most frequent words:&quot;);&#10; &#160;&#160;&#160;for(i,(word, count)) in word_frequencies.iter().take(10).enumerate() {&#10; &#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&quot;{}.{} &#45; {} occurrences&quot;, i + 1, word, count);&#10; &#160;&#160;&#160;}&#10;}">
<ellipse fill="none" stroke="black" cx="377.44" cy="-90" rx="134.58" ry="18"/>
<text text-anchor="middle" x="377.44" y="-86.3" font-family="Times,serif" font-size="14.00">functional_quicksort_demo</text>
</a>
</g>
</g>
<!-- main&#45;&gt;functional_quicksort_demo -->
<g id="edge3" class="edge">
<title>main&#45;&gt;functional_quicksort_demo</title>
<path fill="none" stroke="black" d="M267.61,-148.81C286.71,-138.75 314.26,-124.26 336.98,-112.29"/>
<polygon fill="black" stroke="black" points="338.85,-115.27 346.07,-107.51 335.59,-109.07 338.85,-115.27"/>
</g>
<!-- calculate_value -->
<g id="node2" class="node">
<title>calculate_value</title>
<g id="a_node2"><a xlink:title="{&#10; &#160;&#160;&#160;let sum = a + b;&#10; &#160;&#160;&#160;let product = a * b;&#10; &#160;&#160;&#160;helper::math::multiply(sum, 2) + helper::math::square(product)&#10;}">
<ellipse fill="none" stroke="black" cx="377.44" cy="-162" rx="81.49" ry="18"/>
<text text-anchor="middle" x="377.44" y="-158.3" font-family="Times,serif" font-size="14.00">calculate_value</text>
</a>
</g>
</g>
<!-- process_data -->
<g id="node3" class="node">
<title>process_data</title>
<g id="a_node3"><a xlink:title="{&#10; &#160;&#160;&#160;let data = vec![1, 2, 3, 4, 5];&#10; &#160;&#160;&#160;let processed = helper::data::transform_data(&amp;data);&#10; &#160;&#160;&#160;let result = helper::data::analyze_data(&amp;processed);&#10; &#160;&#160;&#160;println!(&quot;Processing result: {}&quot;, result);&#10;}">
<ellipse fill="none" stroke="black" cx="548.44" cy="-162" rx="71.49" ry="18"/>
<text text-anchor="middle" x="548.44" y="-158.3" font-family="Times,serif" font-size="14.00">process_data</text>
</a>
</g>
</g>
<!-- quicksort -->
<g id="node4" class="node">
<title>quicksort</title>
<g id="a_node4"><a xlink:title="{&#10; &#160;&#160;&#160;let len = arr.len();&#10; &#160;&#160;&#160;if len &lt;= 1 {&#10; &#160;&#160;&#160;&#160;&#160;&#160;&#160;return;&#10; &#160;&#160;&#160;}&#10; &#160;&#160;&#160;let pivot_index = partition(arr);&#10; &#160;&#160;&#160;quicksort(&amp;mut arr[0..pivot_index]);&#10; &#160;&#160;&#160;quicksort(&amp;mut arr[pivot_index + 1..len]);&#10;}">
<ellipse fill="none" stroke="black" cx="112.44" cy="-18" rx="53.89" ry="18"/>
<text text-anchor="middle" x="112.44" y="-14.3" font-family="Times,serif" font-size="14.00">quicksort</text>
</a>
</g>
</g>
<!-- partition -->
<g id="node5" class="node">
<title>partition</title>
<g id="a_node5"><a xlink:title="{&#10; &#160;&#160;&#160;let len = arr.len();&#10; &#160;&#160;&#160;let pivot_index = len &#45; 1;&#10; &#160;&#160;&#160;let pivot = arr[pivot_index].clone();&#10; &#160;&#160;&#160;let mut i = 0;&#10; &#160;&#160;&#160;for j in 0..len &#45; 1 {&#10; &#160;&#160;&#160;&#160;&#160;&#160;&#160;if arr[j] &lt;= pivot {&#10; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;arr.swap(i, j);&#10; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;i += 1;&#10; &#160;&#160;&#160;&#160;&#160;&#160;&#160;}&#10; &#160;&#160;&#160;}&#10; &#160;&#160;&#160;arr.swap(i, pivot_index);&#10; &#160;&#160;&#160;i&#10;}">
<ellipse fill="none" stroke="black" cx="689.44" cy="-162" rx="51.19" ry="18"/>
<text text-anchor="middle" x="689.44" y="-158.3" font-family="Times,serif" font-size="14.00">partition</text>
</a>
</g>
</g>
<!-- basic_quicksort_demo&#45;&gt;quicksort -->
<g id="edge1" class="edge">
<title>basic_quicksort_demo&#45;&gt;quicksort</title>
<path fill="none" stroke="black" d="M112.44,-71.7C112.44,-63.98 112.44,-54.71 112.44,-46.11"/>
<polygon fill="black" stroke="black" points="115.94,-46.1 112.44,-36.1 108.94,-46.1 115.94,-46.1"/>
</g>
<!-- quicksort_functional -->
<g id="node8" class="node">
<title>quicksort_functional</title>
<g id="a_node8"><a xlink:title="{&#10; &#160;&#160;&#160;if items.len() &lt;= 1 {&#10; &#160;&#160;&#160;&#160;&#160;&#160;&#160;return items.to_vec();&#10; &#160;&#160;&#160;}&#10; &#160;&#160;&#160;let pivot = &amp;items[0];&#10; &#160;&#160;&#160;let rest = &amp;items[1..];&#10; &#160;&#160;&#160;let lesser: Vec&lt;T&gt; = rest&#10; &#160;&#160;&#160;&#160;&#160;&#160;.iter()&#10; &#160;&#160;&#160;&#160;&#160;&#160;.filter(|item| compare(item, pivot) == std::cmp::Ordering::Less)&#10; &#160;&#160;&#160;&#160;&#160;&#160;.cloned()&#10; &#160;&#160;&#160;&#160;&#160;&#160;.collect();&#10; &#160;&#160;&#160;let equal: Vec&lt;T&gt; = rest&#10; &#160;&#160;&#160;&#160;&#160;&#160;.iter()&#10; &#160;&#160;&#160;&#160;&#160;&#160;.filter(|item| compare(item, pivot) == std::cmp::Ordering::Equal)&#10; &#160;&#160;&#160;&#160;&#160;&#160;.cloned()&#10; &#160;&#160;&#160;&#160;&#160;&#160;.collect();&#10; &#160;&#160;&#160;let greater: Vec&lt;T&gt; = rest&#10; &#160;&#160;&#160;&#160;&#160;&#160;.iter()&#10; &#160;&#160;&#160;&#160;&#160;&#160;.filter(|item| compare(item, pivot) == std::cmp::Ordering::Greater)&#10; &#160;&#160;&#160;&#160;&#160;&#160;.cloned()&#10; &#160;&#160;&#160;&#160;&#160;&#160;.collect();&#10; &#160;&#160;&#160;let mut result = quicksort_functional(&amp;lesser, compare);&#10; &#160;&#160;&#160;result.push(pivot.clone());&#10; &#160;&#160;&#160;result.extend(equal);&#10; &#160;&#160;&#160;result.extend(quicksort_functional(&amp;greater, compare));&#10; &#160;&#160;&#160;result&#10;}">
<ellipse fill="none" stroke="black" cx="1127.44" cy="-90" rx="104.78" ry="18"/>
<text text-anchor="middle" x="1127.44" y="-86.3" font-family="Times,serif" font-size="14.00">quicksort_functional</text>
</a>
</g>
</g>
<!-- quicksort_functional_ord -->
<g id="node9" class="node">
<title>quicksort_functional_ord</title>
<g id="a_node9"><a xlink:title="{&#10; &#160;&#160;&#160;quicksort_functional(items, |a, b| a.cmp(b))&#10;}">
<ellipse fill="none" stroke="black" cx="883.44" cy="-162" rx="124.58" ry="18"/>
<text text-anchor="middle" x="883.44" y="-158.3" font-family="Times,serif" font-size="14.00">quicksort_functional_ord</text>
</a>
</g>
</g>
<!-- quicksort_functional_ord&#45;&gt;quicksort_functional -->
<g id="edge4" class="edge">
<title>quicksort_functional_ord&#45;&gt;quicksort_functional</title>
<path fill="none" stroke="black" d="M936.99,-145.64C975.14,-134.69 1026.49,-119.96 1066.26,-108.55"/>
<polygon fill="black" stroke="black" points="1067.46,-111.85 1076.11,-105.73 1065.53,-105.12 1067.46,-111.85"/>
</g>
<!-- transform_and_sort -->
<g id="node10" class="node">
<title>transform_and_sort</title>
<g id="a_node10"><a xlink:title="{&#10; &#160;&#160;&#160;let transformed: Vec&lt;U&gt; = data.iter().map(transform).collect();&#10; &#160;&#160;&#160;quicksort_functional(&amp;transformed, compare)&#10;}">
<ellipse fill="none" stroke="black" cx="1127.44" cy="-162" rx="101.28" ry="18"/>
<text text-anchor="middle" x="1127.44" y="-158.3" font-family="Times,serif" font-size="14.00">transform_and_sort</text>
</a>
</g>
</g>
<!-- transform_and_sort&#45;&gt;quicksort_functional -->
<g id="edge5" class="edge">
<title>transform_and_sort&#45;&gt;quicksort_functional</title>
<path fill="none" stroke="black" d="M1127.44,-143.7C1127.44,-135.98 1127.44,-126.71 1127.44,-118.11"/>
<polygon fill="black" stroke="black" points="1130.94,-118.1 1127.44,-108.1 1123.94,-118.1 1130.94,-118.1"/>
</g>
<!-- word_frequency_analysis -->
<g id="node11" class="node">
<title>word_frequency_analysis</title>
<g id="a_node11"><a xlink:title="{&#10; &#160;&#160;&#160;let words: Vec&lt;String&gt; = text&#10; &#160;&#160;&#160;&#160;&#160;&#160;.split_whitespace()&#10; &#160;&#160;&#160;&#160;&#160;&#160;.map(|word| word.trim_matches(|c: char| !c.is_alphabetic()).to_lowercase())&#10; &#160;&#160;&#160;&#160;&#160;&#160;.filter(|word| !word.is_empty())&#10; &#160;&#160;&#160;&#160;&#160;&#160;.collect();&#10; &#160;&#160;&#160;let mut word_counts: Vec&lt;(String, usize)&gt; = Vec::new();&#10; &#160;&#160;&#160;for word in words {&#10; &#160;&#160;&#160;&#160;&#160;&#160;&#160;match word_counts.iter().position(|(w, _)| w == &amp;word) {&#10; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Some(index) =&gt; {&#10; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let(_, count) = word_counts[index];&#10; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;word_counts = word_counts&#10; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.iter()&#10; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.enumerate()&#10; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.map(|(i,(w, c))| {&#10; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if i == index {(w.clone(), c + 1) } else {(w.clone(), *c) }&#10; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;})&#10; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.collect();&#10; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}&#10; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;None =&gt; word_counts.push((word, 1)),&#10; &#160;&#160;&#160;&#160;&#160;&#160;&#160;}&#10; &#160;&#160;&#160;}&#10; &#160;&#160;&#160;quicksort_functional(&amp;word_counts, |a, b| b.1.cmp(&amp;a.1))&#10;}">
<ellipse fill="none" stroke="black" cx="1373.44" cy="-162" rx="126.98" ry="18"/>
<text text-anchor="middle" x="1373.44" y="-158.3" font-family="Times,serif" font-size="14.00">word_frequency_analysis</text>
</a>
</g>
</g>
<!-- word_frequency_analysis&#45;&gt;quicksort_functional -->
<g id="edge6" class="edge">
<title>word_frequency_analysis&#45;&gt;quicksort_functional</title>
<path fill="none" stroke="black" d="M1319.45,-145.64C1280.91,-134.67 1229,-119.9 1188.87,-108.48"/>
<polygon fill="black" stroke="black" points="1189.77,-105.1 1179.19,-105.73 1187.85,-111.83 1189.77,-105.1"/>
</g>
<!-- print_message -->
<g id="node12" class="node">
<title>print_message</title>
<g id="a_node12"><a xlink:title="{&#10; &#160;&#160;&#160;println!(&quot;Message: {}&quot;, msg);&#10;}">
<ellipse fill="none" stroke="black" cx="1596.44" cy="-162" rx="78.79" ry="18"/>
<text text-anchor="middle" x="1596.44" y="-158.3" font-family="Times,serif" font-size="14.00">print_message</text>
</a>
</g>
</g>
<!-- format_string -->
<g id="node13" class="node">
<title>format_string</title>
<g id="a_node13"><a xlink:title="{&#10; &#160;&#160;&#160;format!(&quot;Formatted: {}&quot;, s.to_uppercase())&#10;}">
<ellipse fill="none" stroke="black" cx="1767.44" cy="-162" rx="74.19" ry="18"/>
<text text-anchor="middle" x="1767.44" y="-158.3" font-family="Times,serif" font-size="14.00">format_string</text>
</a>
</g>
</g>
<!-- add -->
<g id="node14" class="node">
<title>add</title>
<g id="a_node14"><a xlink:title="{&#10; &#160;&#160;&#160;a + b&#10;}">
<ellipse fill="none" stroke="black" cx="1887.44" cy="-162" rx="27.9" ry="18"/>
<text text-anchor="middle" x="1887.44" y="-158.3" font-family="Times,serif" font-size="14.00">add</text>
</a>
</g>
</g>
<!-- multiply -->
<g id="node15" class="node">
<title>multiply</title>
<g id="a_node15"><a xlink:title="{&#10; &#160;&#160;&#160;a * b&#10;}">
<ellipse fill="none" stroke="black" cx="1982.44" cy="-162" rx="49.29" ry="18"/>
<text text-anchor="middle" x="1982.44" y="-158.3" font-family="Times,serif" font-size="14.00">multiply</text>
</a>
</g>
</g>
<!-- square -->
<g id="node16" class="node">
<title>square</title>
<g id="a_node16"><a xlink:title="{&#10; &#160;&#160;&#160;a * a&#10;}">
<ellipse fill="none" stroke="black" cx="2092.44" cy="-162" rx="42.49" ry="18"/>
<text text-anchor="middle" x="2092.44" y="-158.3" font-family="Times,serif" font-size="14.00">square</text>
</a>
</g>
</g>
<!-- transform_data -->
<g id="node17" class="node">
<title>transform_data</title>
<g id="a_node17"><a xlink:title="{&#10; &#160;&#160;&#160;data.iter().map(|x| x * 2).collect()&#10;}">
<ellipse fill="none" stroke="black" cx="2234.44" cy="-162" rx="81.79" ry="18"/>
<text text-anchor="middle" x="2234.44" y="-158.3" font-family="Times,serif" font-size="14.00">transform_data</text>
</a>
</g>
</g>
<!-- analyze_data -->
<g id="node18" class="node">
<title>analyze_data</title>
<g id="a_node18"><a xlink:title="{&#10; &#160;&#160;&#160;data.iter().sum()&#10;}">
<ellipse fill="none" stroke="black" cx="2405.44" cy="-162" rx="70.69" ry="18"/>
<text text-anchor="middle" x="2405.44" y="-158.3" font-family="Times,serif" font-size="14.00">analyze_data</text>
</a>
</g>
</g>
<!-- filter_data -->
<g id="node19" class="node">
<title>filter_data</title>
<g id="a_node19"><a xlink:title="{&#10; &#160;&#160;&#160;data.iter().filter(|&amp;&amp;x| x &gt; threshold).cloned().collect()&#10;}">
<ellipse fill="none" stroke="black" cx="2552.44" cy="-162" rx="57.69" ry="18"/>
<text text-anchor="middle" x="2552.44" y="-158.3" font-family="Times,serif" font-size="14.00">filter_data</text>
</a>
</g>
</g>
<!-- calculate -->
<g id="node20" class="node">
<title>calculate</title>
<g id="a_node20"><a xlink:title="{&#10; &#160;&#160;&#160;a + b&#10;}">
<ellipse fill="none" stroke="black" cx="2680.44" cy="-162" rx="51.99" ry="18"/>
<text text-anchor="middle" x="2680.44" y="-158.3" font-family="Times,serif" font-size="14.00">calculate</text>
</a>
</g>
</g>
<!-- Data -->
<g id="node21" class="node">
<title>Data</title>
<g id="a_node21"><a xlink:title="{ # [doc = &quot; The name field&quot;] pub name : String , # [doc = &quot; The value field&quot;] pub value : i32 , }">
<ellipse fill="none" stroke="black" cx="2782.44" cy="-162" rx="32.49" ry="18"/>
<text text-anchor="middle" x="2782.44" y="-158.3" font-family="Times,serif" font-size="14.00">Data</text>
</a>
</g>
</g>
<!-- Data :: new -->
<g id="node22" class="node">
<title>Data :: new</title>
<g id="a_node22"><a xlink:title="{&#10; &#160;&#160;&#160;Self {&#10; &#160;&#160;&#160;&#160;&#160;&#160;&#160;name: name.to_string(),&#10; &#160;&#160;&#160;&#160;&#160;&#160;&#160;value,&#10; &#160;&#160;&#160;}&#10;}">
<ellipse fill="none" stroke="black" cx="2896.44" cy="-162" rx="63.89" ry="18"/>
<text text-anchor="middle" x="2896.44" y="-158.3" font-family="Times,serif" font-size="14.00">Data :: new</text>
</a>
</g>
</g>
</g>
</svg>
