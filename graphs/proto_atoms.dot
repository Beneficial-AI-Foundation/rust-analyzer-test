digraph call_graph {
  rankdir=LR;
  node [shape=box, style=filled, fillcolor=lightblue, fontname=Helvetica];
  edge [color=gray];

  subgraph cluster_0 {
    label = "/home/lacra/git_repos/libsignal/rust/protocol/src";
    style=filled;
    color=lightgrey;
    fontname=Helvetica;
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#BadKEMKeyLength#" [label="BadKEMKeyLength", tooltip="    /// bad KEM ciphertext length <     BadKEMKeyLength(kem::KeyType, usize), {1}> for key with type <{0}>     BadKEMCiphertextLength(kem::KeyType, usize), }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/CurrentOrPrevious#Previous#" [label="Previous", tooltip="            '              );         }         log::error!( {}' ,             create_decryption_failure_log(remote_address, &errs, record, ciphertext)?         );         Err(SignalProtocolError::Inv..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/impl#[SignalProtocolError]for_application_callback()." [label="for_application_callback", tooltip="    ) -> impl FnOnce(E) -> Self      pub fn for_application_callback<E: std::error::Error + Send + Sync + UnwindSafe + 'static>(         method: &'static str, {         move |error| Self::ApplicationC..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/Parameters#generate()." [label="generate", tooltip="trait DynParameters      fn generate() -> (KeyMaterial<Public>, KeyMaterial<Secret>);     fn encapsulate(pub_key: &KeyMaterial<Public>) -> (SharedSecret, RawCiphertext);     fn decapsulate(secret_key:..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/calculate_chunk_size()." [label="calculate_chunk_size", tooltip="pub const fn calculate_chunk_size<D>(data_size: usize) -> usize where     D: FixedOutput,     D::OutputSize: ArrayLength<u8>, {     assert!(         0 == TARGET_TOTAL_DIGEST_SIZE % D::OutputSize::USIZ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidSessionStructure#" [label="InvalidSessionStructure", tooltip="    /// invalid sender key session with distribution ID      InvalidSessionStructure(&'static str), {distribution_id}     InvalidSenderKeySession { distribution_id: Uuid },     /// session for {0} has..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 session/process_prekey()." [label="process_prekey", tooltip=") -> Result<PreKeysUsed>  pub async fn process_prekey(     message: &PreKeySignalMessage,     remote_address: &ProtocolAddress,     session_record: &mut SessionRecord,     identity_store: &mut dyn Ide..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidProtobufEncoding#" [label="InvalidProtobufEncoding", tooltip="    /// ciphertext serialized bytes were too short <     InvalidProtobufEncoding,  {0}>     CiphertextMessageTooShort(usize),     /// ciphertext version was too old <{0}>     LegacyCiphertextVersion(u..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v1/test_agreement_and_authentication()." [label="test_agreement_and_authentication", tooltip="    fn test_agreement_and_authentication() -> Result<()>  {         // The sender and recipient each have a long-term identity key pair.         let sender_identity = IdentityKeyPair::generate(&mut ra..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/decrypt_message_with_state()." [label="decrypt_message_with_state", tooltip="enum CurrentOrPrevious   #[derive(Clone, Copy)] {     Current,     Previous, }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[ServerCertificate]new()." [label="new", tooltip="    ) -> Result<Self>      pub fn new<R: Rng + CryptoRng>(         key_id: u32,         key: PublicKey,         trust_root: &PrivateKey,         rng: &mut R, {         let certificate_pb = proto::seal..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/ContentHint#Unknown#" [label="Unknown", tooltip="impl ContentHint      Unknown(u32), }  {     fn to_proto(self) -> Option<i32> {         if self == ContentHint::Default {             None         } else {             Some(u32::from(self) as i32)    ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SenderKeyDistributionMessage]new()." [label="new", tooltip="    ) -> Result<Self>      pub fn new(         message_version: u8,         distribution_id: Uuid,         chain_id: u32,         iteration: u32,         chain_key: Vec<u8>,         signing_key: Publi..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/group_decrypt()." [label="group_decrypt", tooltip=") -> Result<Vec<u8>>  pub async fn group_decrypt(     skm_bytes: &[u8],     sender_key_store: &mut dyn SenderKeyStore,     sender: &ProtocolAddress, {     let skm = SenderKeyMessage::try_from(skm_byte..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/tests/test_kyber768_keypair()." [label="test_kyber768_keypair", tooltip="    fn test_kyber768_keypair()  {         let kp = KeyPair::generate(KeyType::Kyber768);         assert_eq!(             kyber768::Parameters::SECRET_KEY_LENGTH + 1,             kp.secret_key.serializ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#FfiBindingError#" [label="FfiBindingError", tooltip="    /// error in method call '     FfiBindingError(String), {0}': {1}     ApplicationCallbackError(         &'static str,         #[source] Box<dyn std::error::Error + Send + Sync + UnwindSafe + 'stat..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/test/fingerprint_matching_identifiers()." [label="fingerprint_matching_identifiers", tooltip="    fn fingerprint_matching_identifiers() -> Result<()>  {         // testMatchingFingerprints          use rand::rngs::OsRng;          use crate::IdentityKeyPair;          let a_key_pair = IdentityKe..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[KeyType][`TryFrom<u8>`]try_from()." [label="try_from", tooltip="    fn try_from(x: u8) -> Result<Self>  {         match x {             #[cfg(any(feature = ' kyber768' , test))]             0x07 => Ok(KeyType::Kyber768),             0x08 => Ok(KeyType::Kyber1024),..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/produce_and_validate()." [label="produce_and_validate", tooltip="    fn produce_and_validate()  {         let key = TEST_HMAC_KEY;          proptest!(|(input in ' .{0,100}' )| {             let bytes = input.as_bytes();             let mut incremental = new_increme..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/chunk_sizes_sha512()." [label="chunk_sizes_sha512", tooltip="    fn chunk_sizes_sha512()  {         for (data_size, expected) in [             (0, MINIMUM_CHUNK_SIZE),             (KIBIBYTES, MINIMUM_CHUNK_SIZE),             (10 * KIBIBYTES, MINIMUM_CHUNK_SIZE)..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/UnidentifiedSenderMessage#V2#" [label="V2", tooltip="    V2  {         ephemeral_public: PublicKey,         encrypted_message_key: &'a [u8; sealed_sender_v2::MESSAGE_KEY_LEN],         authentication_tag: &'a [u8; sealed_sender_v2::AUTH_TAG_LEN],        ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/derive_keys_with_label()." [label="derive_keys_with_label", tooltip="fn derive_keys_with_label(label: &[u8], secret_input: &[u8]) -> (RootKey, ChainKey)  {     let mut secrets = [0; 64];     hkdf::Hkdf::<sha2::Sha256>::new(None, secret_input)         .expand(label, &mu..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/final_result_should_be_equal_to_non_incremental_hmac()." [label="final_result_should_be_equal_to_non_incremental_hmac", tooltip="    fn final_result_should_be_equal_to_non_incremental_hmac()  {         let key = TEST_HMAC_KEY;         proptest!(|(input in ' .{0,100}' )| {             let bytes = input.as_bytes();             le..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/ContentHint#Default#" [label="Default", tooltip="impl ContentHint      Default,     Resendable,     Implicit,     Unknown(u32), }  {     fn to_proto(self) -> Option<i32> {         if self == ContentHint::Default {             None         } else {  ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKeyPair]generate()." [label="generate", tooltip="    pub fn generate<R: CryptoRng + Rng>(csprng: &mut R) -> Self  {         let keypair = KeyPair::generate(csprng);          Self {             identity_key: keypair.public_key.into(),             pri..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/incremental_macs_are_valid()." [label="incremental_macs_are_valid", tooltip="    fn incremental_macs_are_valid()  {         let key = TEST_HMAC_KEY;          proptest!(|(input in ' .{50,100}' )| {             let bytes = input.as_bytes();             let mut incremental = new_..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKeyPair][`TryFrom<PrivateKey>`]try_from()." [label="try_from", tooltip="    fn try_from(private_key: PrivateKey) -> Result<Self>  {         let identity_key = IdentityKey::new(private_key.public_key()?);         Ok(Self::new(identity_key, private_key))     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/tests/test_identity_key_from()." [label="test_identity_key_from", tooltip="    fn test_identity_key_from()  {         let key_pair = KeyPair::generate(&mut OsRng);         let key_pair_public_serialized = key_pair.public_key.serialize();         let identity_key = IdentityKe..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[PlaintextContent][`TryFrom<&[u8]>`]try_from()." [label="try_from", tooltip="    fn try_from(value: &[u8]) -> Result<Self>  {         if value.is_empty() {             return Err(SignalProtocolError::CiphertextMessageTooShort(0));         }         if value[0] != Self::PLAINTE..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/tests/test_alternate_identity_signing()." [label="test_alternate_identity_signing", tooltip="    fn test_alternate_identity_signing() -> Result<()>  {         let primary = IdentityKeyPair::generate(&mut OsRng);         let secondary = IdentityKeyPair::generate(&mut OsRng);          let signa..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/Parameters#encapsulate()." [label="encapsulate", tooltip="trait DynParameters      fn encapsulate(pub_key: &KeyMaterial<Public>) -> (SharedSecret, RawCiphertext);     fn decapsulate(secret_key: &KeyMaterial<Secret>, ciphertext: &[u8]) -> Result<SharedSecret>..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/process_sender_key_distribution_message()." [label="process_sender_key_distribution_message", tooltip=") -> Result<()>  pub async fn process_sender_key_distribution_message(     sender: &ProtocolAddress,     skdm: &SenderKeyDistributionMessage,     sender_key_store: &mut dyn SenderKeyStore, {     let d..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/test_agreement_and_authentication()." [label="test_agreement_and_authentication", tooltip="    fn test_agreement_and_authentication() -> Result<()>  {         // The sender and recipient each have a long-term identity key pair.         let sender_identity = IdentityKeyPair::generate(&mut ra..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/create_sender_key_distribution_message()." [label="create_sender_key_distribution_message", tooltip=") -> Result<SenderKeyDistributionMessage>  pub async fn create_sender_key_distribution_message<R: Rng + CryptoRng>(     sender: &ProtocolAddress,     distribution_id: Uuid,     sender_key_store: &mut ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/get_encoded_string()." [label="get_encoded_string", tooltip="fn get_encoded_string(fprint: &[u8]) -> Result<String>  {     if fprint.len() < 30 {         return Err(SignalProtocolError::InvalidArgument(             ' DisplayableFingerprint created with short en..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[UnidentifiedSenderMessageContent]deserialize()." [label="deserialize", tooltip="    pub fn deserialize(data: &[u8]) -> Result<Self>  {         let pb = proto::sealed_sender::unidentified_sender_message::Message::decode(data)             .map_err(|_| SignalProtocolError::InvalidPr..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/impl#[DisplayableFingerprint]new()." [label="new", tooltip="    pub fn new(local: &[u8], remote: &[u8]) -> Result<Self>  {         Ok(Self {             local: get_encoded_string(local)?,             remote: get_encoded_string(remote)?,         })     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/impl#[ScannableFingerprint]deserialize()." [label="deserialize", tooltip="    pub fn deserialize(protobuf: &[u8]) -> Result<Self>  {         let fingerprint = proto::fingerprint::CombinedFingerprints::decode(protobuf)             .map_err(|_| SignalProtocolError::Fingerprin..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/impl#[Fingerprint]get_fingerprint()." [label="get_fingerprint", tooltip="    ) -> Result<Vec<u8>>      fn get_fingerprint(         iterations: u32,         local_id: &[u8],         local_key: &IdentityKey, {         if iterations <= 1 || iterations > 1000000 {             ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/test/aes_ctr_test()." [label="aes_ctr_test", tooltip="    fn aes_ctr_test()  {         let key = hex!(' 603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4' );         let ptext = [0u8; 35];          let ctext = aes_256_ctr_encrypt(&ptext, &..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/KeyType#Kyber1024#" [label="Kyber1024", tooltip="impl KeyType      Kyber1024,     /// ML-KEM 1024 key     #[cfg(feature = ' mlkem1024' )]     MLKEM1024, }  {     fn value(&self) -> u8 {         match self {             #[cfg(any(feature = ' kyber768..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/ContentHint#Implicit#" [label="Implicit", tooltip="impl ContentHint      Implicit,     Unknown(u32), }  {     fn to_proto(self) -> Option<i32> {         if self == ContentHint::Default {             None         } else {             Some(u32::from(sel..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#Plaintext#" [label="Plaintext", tooltip="impl CiphertextMessage      Plaintext = 8, }  {     pub fn message_type(&self) -> CiphertextMessageType {         match self {             CiphertextMessage::SignalMessage(_) => CiphertextMessageType:..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/append_session_summary()." [label="append_session_summary", tooltip="    )      fn append_session_summary(         lines: &mut Vec<String>,         idx: usize,         state: std::result::Result<&SessionState, InvalidSessionError>,         err: Option<&SignalProtocolEr..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#FingerprintParsingError#" [label="FingerprintParsingError", tooltip="    /// bad key type <     FingerprintParsingError,      /// no key type identifier     NoKeyTypeIdentifier, {0:#04x}>     BadKeyType(u8),     /// bad key length <{1}> for key with type <{0}>     BadK..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Key<T>`]deserialize()." [label="deserialize", tooltip="    pub fn deserialize(value: &[u8]) -> Result<Self>  {         if value.is_empty() {             return Err(SignalProtocolError::NoKeyTypeIdentifier);         }         let key_type = KeyType::try_fr..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderKeyRecord]deserialize()." [label="deserialize", tooltip="    pub fn deserialize(buf: &[u8]) -> Result<SenderKeyRecord, SignalProtocolError>  {         let skr = storage_proto::SenderKeyRecordStructure::decode(buf)             .map_err(|_| SignalProtocolErro..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#BadKeyLength#" [label="BadKeyLength", tooltip="    /// untrusted identity for address      BadKeyLength(KeyType, usize),      /// invalid signature detected     SignatureValidationFailed,  {0}     UntrustedIdentity(crate::ProtocolAddress),      //..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/test/fingerprint_encodings()." [label="fingerprint_encodings", tooltip="    fn fingerprint_encodings() -> Result<()>  {         let l = vec![0x12; 32];         let r = vec![0xBA; 32];          let fprint2 = ScannableFingerprint::new(2, &l, &r);         let proto2 = fprint..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Key<Secret>`][`TryFrom<&[u8]>`]try_from()." [label="try_from", tooltip="    fn try_from(value: &[u8]) -> Result<Self>  {         Self::deserialize(value)     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/initialize_alice_session_record()." [label="initialize_alice_session_record", tooltip=") -> Result<SessionRecord>  pub fn initialize_alice_session_record<R: Rng + CryptoRng>(     parameters: &AliceSignalProtocolParameters,     csprng: &mut R, {     Ok(SessionRecord::new(initialize_alice..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_pre_key_signal_message_serialize_deserialize()." [label="test_pre_key_signal_message_serialize_deserialize", tooltip="    fn test_pre_key_signal_message_serialize_deserialize() -> Result<()>  {         let mut csprng = OsRng;         let identity_key_pair = KeyPair::generate(&mut csprng);         let base_key_pair = ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidMessage#" [label="InvalidMessage", tooltip="    /// error while invoking an ffi callback:      InvalidMessage(crate::CiphertextMessageType, &'static str),  {0}     FfiBindingError(String),     /// error in method call '{0}': {1}     Application..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/DecryptionError#BadKeyOrIv#" [label="BadKeyOrIv", tooltip="fn aes_256_ctr_encrypt(ptext: &[u8], key: &[u8]) -> Result<Vec<u8>, EncryptionError>      BadKeyOrIv,     /// Either the input is malformed, or the MAC doesn't match on decryption.     ///     /// The..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/decode_varint()." [label="decode_varint", tooltip="        fn decode_varint(buf: &mut &[u8]) -> Result<u32>  {             let result: usize = prost::decode_length_delimiter(*buf)                 .map_err(|_| SignalProtocolError::InvalidProtobufEncodi..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/tests/test_serialize()." [label="test_serialize", tooltip="    fn test_serialize()  {         let pk_bytes = include_bytes!(' kem/test-data/pk.dat' );         let sk_bytes = include_bytes!(' kem/test-data/sk.dat' );          let mut serialized_pk = Vec::with_..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[ServerCertificate]deserialize()." [label="deserialize", tooltip="    pub fn deserialize(data: &[u8]) -> Result<Self>  {         let pb = proto::sealed_sender::ServerCertificate::decode(data)             .map_err(|_| SignalProtocolError::InvalidProtobufEncoding)?;  ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[KyberPayload]new()." [label="new", tooltip="    pub fn new(id: KyberPreKeyId, ciphertext: kem::SerializedCiphertext) -> Self  {         Self {             pre_key_id: id,             ciphertext,         }     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKeyPair][`From<KeyPair>`]from()." [label="from", tooltip="    fn from(value: KeyPair) -> Self  {         Self {             identity_key: value.public_key.into(),             private_key: value.private_key,         }     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/chain_key()." [label="chain_key", tooltip="    fn chain_key(i: u128) -> Vec<u8>  {         i.to_be_bytes().to_vec()     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#UnrecognizedCiphertextVersion#" [label="UnrecognizedCiphertextVersion", tooltip="    /// unrecognized message version <     UnrecognizedCiphertextVersion(u8), {0}>     UnrecognizedMessageVersion(u32),      /// fingerprint version number mismatch them {0} us {1}     FingerprintVers..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/impl#[`Incremental<M>`]new()." [label="new", tooltip="    pub fn new(mac: M, chunk_size: usize) -> Self  {         assert!(chunk_size > 0, ' chunk size must be positive' );         Self {             mac,             chunk_size,             unused_length..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#PreKey#" [label="PreKey", tooltip="impl CiphertextMessage      PreKey = 3,     SenderKey = 7,     Plaintext = 8, }  {     pub fn message_type(&self) -> CiphertextMessageType {         match self {             CiphertextMessage::SignalM..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/tests/test_dyn_parameters_consts()." [label="test_dyn_parameters_consts", tooltip="    fn test_dyn_parameters_consts()  {         assert_eq!(             kyber1024::Parameters::SECRET_KEY_LENGTH,             kyber1024::Parameters.secret_key_length()         );         assert_eq!(   ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/group_encrypt()." [label="group_encrypt", tooltip=") -> Result<SenderKeyMessage>  pub async fn group_encrypt<R: Rng + CryptoRng>(     sender_key_store: &mut dyn SenderKeyStore,     sender: &ProtocolAddress,     distribution_id: Uuid,     plaintext: &[..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt_to_usmc()." [label="sealed_sender_decrypt_to_usmc", tooltip=") -> Result<UnidentifiedSenderMessageContent>  pub async fn sealed_sender_decrypt_to_usmc(     ciphertext: &[u8],     identity_store: &dyn IdentityKeyStore, {     let our_identity = identity_store.get..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[KeyPair][`From<IdentityKeyPair>`]from()." [label="from", tooltip="    fn from(value: IdentityKeyPair) -> Self  {         Self::new(value.identity_key.into(), value.private_key)     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#BadKEMCiphertextLength#" [label="BadKEMCiphertextLength", tooltip="impl SignalProtocolError      BadKEMCiphertextLength(kem::KeyType, usize), }  {     /// Convenience factory for [`SignalProtocolError::ApplicationCallbackError`].     #[inline]     pub fn for_applicat..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidState#" [label="InvalidState", tooltip="    /// ciphertext serialized bytes were too short <     InvalidState(&'static str, String),      /// protobuf encoding was invalid     InvalidProtobufEncoding,  {0}>     CiphertextMessageTooShort(usi..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#UnknownSealedSenderVersion#" [label="UnknownSealedSenderVersion", tooltip="    /// bad KEM key type <     UnknownSealedSenderVersion(u8),     /// self send of a sealed sender message     SealedSenderSelfSend,  {0:#04x}>     BadKEMKeyType(u8),     /// unexpected KEM key type ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidMacKeyLength#" [label="InvalidMacKeyLength", tooltip="    /// missing sender key state for distribution ID      InvalidMacKeyLength(usize),  {distribution_id}     NoSenderKeyState { distribution_id: Uuid },      /// session with {0} not found     Session..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_chain_key_iteration_tests/iteration()." [label="iteration", tooltip="    fn iteration()  {         let mut sender_chain_key =             SenderChainKey::new(INITIAL_ITERATION, INITIAL_SEED_KEY.to_vec());          let mut seen_seeds = HashSet::new();         seen_seeds..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SignalMessage]new()." [label="new", tooltip="    ) -> Result<Self>      pub fn new(         message_version: u8,         mac_key: &[u8],         sender_ratchet_key: PublicKey,         counter: u32,         previous_counter: u32,         cipherte..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/KeyKind#key_length()." [label="key_length", tooltip="pub enum Public      fn key_length(key_type: KeyType) -> usize; }  {}  impl KeyKind for Public {     fn key_length(key_type: KeyType) -> usize {         key_type.parameters().public_key_length()     }..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v1/impl#[EphemeralKeys]calculate()." [label="calculate", tooltip="        ) -> Result<Self>          pub(super) fn calculate(             our_keys: &KeyPair,             their_public: &PublicKey,             direction: Direction, {             let our_pub_key = our_..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#ApplicationCallbackError#" [label="ApplicationCallbackError", tooltip="    /// invalid sealed sender message:      ApplicationCallbackError(         &'static str,         #[source] Box<dyn std::error::Error + Send + Sync + UnwindSafe + 'static>,     ),  {0}     InvalidSe..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 session/process_prekey_bundle()." [label="process_prekey_bundle", tooltip=") -> Result<()>  pub async fn process_prekey_bundle<R: Rng + CryptoRng>(     remote_address: &ProtocolAddress,     session_store: &mut dyn SessionStore,     identity_store: &mut dyn IdentityKeyStore, ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKey]new()." [label="new", tooltip="    pub fn new(public_key: PublicKey) -> Self  {         Self { public_key }     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SenderKeyMessage][`TryFrom<&[u8]>`]try_from()." [label="try_from", tooltip="    fn try_from(value: &[u8]) -> Result<Self>  {         if value.len() < 1 + Self::SIGNATURE_LEN {             return Err(SignalProtocolError::CiphertextMessageTooShort(value.len()));         }      ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/tests/test_serialize_identity_key_pair()." [label="test_serialize_identity_key_pair", tooltip="    fn test_serialize_identity_key_pair() -> Result<()>  {         let identity_key_pair = IdentityKeyPair::generate(&mut OsRng);         let serialized = identity_key_pair.serialize();         let de..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessage#PreKeySignalMessage#" [label="PreKeySignalMessage", tooltip="pub enum CiphertextMessageType      PreKeySignalMessage(PreKeySignalMessage),     SenderKeyMessage(SenderKeyMessage),     PlaintextContent(PlaintextContent), }  #[derive(Copy, Clone, Eq, PartialEq, De..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#Whisper#" [label="Whisper", tooltip="impl CiphertextMessage      Whisper = 2,     PreKey = 3,     SenderKey = 7,     Plaintext = 8, }  {     pub fn message_type(&self) -> CiphertextMessageType {         match self {             Ciphertex..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidRegistrationId#" [label="InvalidRegistrationId", tooltip="    /// message with old counter      InvalidRegistrationId(crate::ProtocolAddress, u32),  {0} / {1}     DuplicatedMessage(u32, u32),     /// invalid {0:?} message: {1}     InvalidMessage(crate::Ciphe..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SenderKeyDistributionMessage][`TryFrom<&[u8]>`]try_from()." [label="try_from", tooltip="    fn try_from(value: &[u8]) -> Result<Self>  {         // The message contains at least a X25519 key and a chain key         if value.len() < 1 + 32 + 32 {             return Err(SignalProtocolError..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/UnidentifiedSenderMessage#V1#" [label="V1", tooltip="    V1  {         ephemeral_public: PublicKey,         encrypted_static: Vec<u8>,         encrypted_message: Vec<u8>,     },"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/add_second_state()." [label="add_second_state", tooltip="    fn add_second_state()  {         let mut context = TestContext::new();          let chain_id_1 = 1;         let chain_id_2 = 2;         let record_key_1 = (random_public_key(), chain_id_1);       ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/add_single_state()." [label="add_single_state", tooltip="    fn add_single_state()  {         let mut context = TestContext::new();          let public_key = random_public_key();         let chain_id = 1;         let chain_key = chain_key(1);         let re..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/derive_keys()." [label="derive_keys", tooltip="fn derive_keys(has_kyber: bool, secret_input: &[u8]) -> (RootKey, ChainKey)  {     let label = if has_kyber {         b' WhisperText_X25519_SHA-256_CRYSTALS-KYBER-1024' .as_slice()     } else {       ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/assert_signal_message_equals()." [label="assert_signal_message_equals", tooltip="    fn assert_signal_message_equals(m1: &SignalMessage, m2: &SignalMessage)  {         assert_eq!(m1.message_version, m2.message_version);         assert_eq!(m1.sender_ratchet_key, m2.sender_ratchet_k..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[`SealedSenderV2SentMessage<'a>`]parse()." [label="parse", tooltip="    pub fn parse(data: &'a [u8]) -> Result<Self>  {         if data.is_empty() {             return Err(SignalProtocolError::InvalidSealedSenderMessage(                 ' Message was empty' .to_owned(..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/Parameters#decapsulate()." [label="decapsulate", tooltip="trait DynParameters      fn decapsulate(secret_key: &KeyMaterial<Secret>, ciphertext: &[u8]) -> Result<SharedSecret>; }  /// Acts as a bridge between the static [Parameters] trait and the dynamic [Key..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/decrypt_message_with_record()." [label="decrypt_message_with_record", tooltip=") -> Result<Vec<u8>>  fn decrypt_message_with_record<R: Rng + CryptoRng>(     remote_address: &ProtocolAddress,     record: &mut SessionRecord,     ciphertext: &SignalMessage,     original_message_typ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/new_incremental()." [label="new_incremental", tooltip="    fn new_incremental(key: &[u8], chunk_size: usize) -> Incremental<Hmac<Sha256>>  {         let hmac = Hmac::<Sha256>::new_from_slice(key)             .expect(' Should be able to create a new HMAC i..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKey][`TryFrom<&[u8]>`]try_from()." [label="try_from", tooltip="    fn try_from(value: &[u8]) -> Result<Self>  {         IdentityKey::decode(value)     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/impl#[ScannableFingerprint]new()." [label="new", tooltip="    fn new(version: u32, local_fprint: &[u8], remote_fprint: &[u8]) -> Self  {         Self {             version,             local_fingerprint: local_fprint[..32].to_vec(),             remote_finger..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/test/fingerprint_mismatching_identifiers()." [label="fingerprint_mismatching_identifiers", tooltip="    fn fingerprint_mismatching_identifiers() -> Result<()>  {         use rand::rngs::OsRng;          use crate::IdentityKeyPair;          let a_key_pair = IdentityKeyPair::generate(&mut OsRng);      ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/test/fingerprint_mismatching_versions()." [label="fingerprint_mismatching_versions", tooltip="    fn fingerprint_mismatching_versions() -> Result<()>  {         let a_key = IdentityKey::decode(ALICE_IDENTITY)?;         let b_key = IdentityKey::decode(BOB_IDENTITY)?;          let iterations = 5..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidKyberPreKeyId#" [label="InvalidKyberPreKeyId", tooltip="    /// invalid MAC key length <     InvalidKyberPreKeyId,  {0}>     InvalidMacKeyLength(usize),      /// missing sender key state for distribution ID {distribution_id}     NoSenderKeyState { distribu..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_decryption_error_message_for_plaintext()." [label="test_decryption_error_message_for_plaintext", tooltip="    fn test_decryption_error_message_for_plaintext()  {         assert!(matches!(             DecryptionErrorMessage::for_original(                 &[],                 CiphertextMessageType::Plaintex..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/aes256_ctr_hmacsha256_encrypt()." [label="aes256_ctr_hmacsha256_encrypt", tooltip=") -> Result<Vec<u8>, EncryptionError>  pub(crate) fn aes256_ctr_hmacsha256_encrypt(     msg: &[u8],     cipher_key: &[u8],     mac_key: &[u8], {     let mut ctext = aes_256_ctr_encrypt(msg, cipher_key..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 timestamp/impl#[`std::time::SystemTime`][`From<Timestamp>`]from()." [label="from", tooltip="    fn from(value: Timestamp) -> Self  {         Self::UNIX_EPOCH + std::time::Duration::from_millis(value.epoch_millis())     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/CurrentOrPrevious#Current#" [label="Current", tooltip="            '                  previous_state_count(),             );         }         log::error!( {}' ,             create_decryption_failure_log(remote_address, &errs, record, ciphertext)?        ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[u32][`From<ContentHint>`]from()." [label="from", tooltip="    fn from(hint: ContentHint) -> Self  {         hint.to_u32()     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/message_version()." [label="message_version", tooltip="fn message_version(has_kyber: bool) -> u8  {     if has_kyber {         CIPHERTEXT_MESSAGE_CURRENT_VERSION     } else {         CIPHERTEXT_MESSAGE_PRE_KYBER_VERSION     } }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_decrypt_prekey()." [label="message_decrypt_prekey", tooltip=") -> Result<Vec<u8>>  pub async fn message_decrypt_prekey<R: Rng + CryptoRng>(     ciphertext: &PreKeySignalMessage,     remote_address: &ProtocolAddress,     session_store: &mut dyn SessionStore,    ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_multi_recipient_encrypt()." [label="sealed_sender_multi_recipient_encrypt", tooltip="pub async fn sealed_sender_multi_recipient_encrypt<     R: Rng + CryptoRng,     X: IntoIterator<Item = ServiceId>, >(     destinations: &[&ProtocolAddress],     destination_sessions: &[&SessionRecord]..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`KeyMaterial<T>`]new()." [label="new", tooltip="    fn new(data: Box<[u8]>) -> Self  {         KeyMaterial {             data,             kind: PhantomData,         }     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKeyPair][`TryFrom<&[u8]>`]try_from()." [label="try_from", tooltip="    fn try_from(value: &[u8]) -> Result<Self>  {         let structure = proto::storage::IdentityKeyPairStructure::decode(value)             .map_err(|_| SignalProtocolError::InvalidProtobufEncoding)?..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[PreKeySignalMessage]new()." [label="new", tooltip="    ) -> Result<Self>      pub fn new(         message_version: u8,         registration_id: u32,         pre_key_id: Option<PreKeyId>,         signed_pre_key_id: SignedPreKeyId,         kyber_payload..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[KeyPair]generate()." [label="generate", tooltip="    pub fn generate(key_type: KeyType) -> Self  {         let (pk, sk) = key_type.parameters().generate();         Self {             secret_key: SecretKey {                 key_type,                 ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/KeyType#Kyber768#" [label="Kyber768", tooltip="impl KeyType      Kyber768,     /// Kyber1024 key     Kyber1024,     /// ML-KEM 1024 key     #[cfg(feature = ' mlkem1024' )]     MLKEM1024, }  {     fn value(&self) -> u8 {         match self {       ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/extract_decryption_error_message_from_serialized_content()." [label="extract_decryption_error_message_from_serialized_content", tooltip=") -> Result<DecryptionErrorMessage>  pub fn extract_decryption_error_message_from_serialized_content(     bytes: &[u8], {     if bytes.last() != Some(&PlaintextContent::PADDING_BOUNDARY_BYTE) {       ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/impl#[DerivedKeys]new()." [label="new", tooltip="        pub(super) fn new(m: &[u8]) -> DerivedKeys  {             Self {                 kdf: hkdf::Hkdf::<sha2::Sha256>::new(None, m),             }         }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKeyPair]new()." [label="new", tooltip="    pub fn new(identity_key: IdentityKey, private_key: PrivateKey) -> Self  {         Self {             identity_key,             private_key,         }     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/get_sender_key()." [label="get_sender_key", tooltip=") -> Result<SenderMessageKey>  fn get_sender_key(     state: &mut SenderKeyState,     iteration: u32,     distribution_id: Uuid, {     let sender_chain_key = state         .sender_chain_key()         ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/test/fingerprint_test_v1()." [label="fingerprint_test_v1", tooltip="    fn fingerprint_test_v1() -> Result<()>  {         // testVectorsVersion1 in Java          let a_key = IdentityKey::decode(ALICE_IDENTITY)?;         let b_key = IdentityKey::decode(BOB_IDENTITY)?; ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidSignedPreKeyId#" [label="InvalidSignedPreKeyId", tooltip="    /// invalid MAC key length <     InvalidSignedPreKeyId,     /// invalid Kyber prekey identifier     InvalidKyberPreKeyId,  {0}>     InvalidMacKeyLength(usize),      /// missing sender key state fo..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/aes_256_ctr_decrypt()." [label="aes_256_ctr_decrypt", tooltip="fn aes_256_ctr_decrypt(ctext: &[u8], key: &[u8]) -> Result<Vec<u8>, DecryptionError>  {     aes_256_ctr_encrypt(ctext, key).map_err(|e| match e {         EncryptionError::BadKeyOrIv => DecryptionError..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt()." [label="sealed_sender_decrypt", tooltip=") -> Result<SealedSenderDecryptionResult>  pub async fn sealed_sender_decrypt(     ciphertext: &[u8],     trust_root: &PublicKey,     timestamp: Timestamp,     local_e164: Option<String>,     local_uu..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_encrypt_from_usmc()." [label="sealed_sender_encrypt_from_usmc", tooltip=") -> Result<Vec<u8>>  pub async fn sealed_sender_encrypt_from_usmc<R: Rng + CryptoRng>(     destination: &ProtocolAddress,     usmc: &UnidentifiedSenderMessageContent,     identity_store: &dyn Identit..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderKeyState]from_protobuf()." [label="from_protobuf", tooltip="    pub(crate) fn from_protobuf(state: storage_proto::SenderKeyStateStructure) -> Self  {         Self { state }     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/when_second_state_with_different_public_key_but_same_chain_id_added_then_it_gets_replaced()." [label="when_second_state_with_different_public_key_but_same_chain_id_added_then_it_gets_replaced", tooltip="    fn when_second_state_with_different_public_key_but_same_chain_id_added_then_it_gets_replaced()  {         let mut context = TestContext::new();          let chain_id = 1;         let record_key_1 ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#SignatureValidationFailed#" [label="SignatureValidationFailed", tooltip="    /// untrusted identity for address      SignatureValidationFailed,  {0}     UntrustedIdentity(crate::ProtocolAddress),      /// invalid prekey identifier     InvalidPreKeyId,     /// invalid signe..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/compute_authentication_tag()." [label="compute_authentication_tag", tooltip="    ) -> Result<[u8; AUTH_TAG_LEN]>      pub(super) fn compute_authentication_tag(         our_keys: &IdentityKeyPair,         their_key: &IdentityKey,         direction: Direction,         ephemeral_..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[KeyPair]from_public_and_private()." [label="from_public_and_private", tooltip="    pub fn from_public_and_private(public_key: &[u8], secret_key: &[u8]) -> Result<Self>  {         let public_key = PublicKey::try_from(public_key)?;         let secret_key = SecretKey::try_from(secr..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#SessionNotFound#" [label="SessionNotFound", tooltip="    /// invalid session:      SessionNotFound(crate::ProtocolAddress), {0}     InvalidSessionStructure(&'static str),     /// invalid sender key session with distribution ID {distribution_id}     Inva..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[ContentHint][`From<u32>`]from()." [label="from", tooltip="    fn from(raw_value: u32) -> Self  {         use proto::sealed_sender::unidentified_sender_message::message::ContentHint as ProtoContentHint;         assert!(!ProtoContentHint::is_valid(0));        ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#NoKeyTypeIdentifier#" [label="NoKeyTypeIdentifier", tooltip="    /// bad key type <     NoKeyTypeIdentifier, {0:#04x}>     BadKeyType(u8),     /// bad key length <{1}> for key with type <{0}>     BadKeyLength(KeyType, usize),      /// invalid signature detected..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/EncryptionError#BadKeyOrIv#" [label="BadKeyOrIv", tooltip="pub(crate) enum DecryptionError      BadKeyOrIv, }  #[derive(Debug)] {     /// The key or IV is the wrong length.     BadKeyOrIv,     /// Either the input is malformed, or the MAC doesn't match on dec..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderMessageKey]new()." [label="new", tooltip="    pub(crate) fn new(iteration: u32, seed: Vec<u8>) -> Self  {         let mut derived = [0; 48];         hkdf::Hkdf::<sha2::Sha256>::new(None, &seed)             .expand(b' WhisperGroup' , &mut deri..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidArgument#" [label="InvalidArgument", tooltip="    /// invalid state for call to      InvalidArgument(String), {0} to succeed: {1}     InvalidState(&'static str, String),      /// protobuf encoding was invalid     InvalidProtobufEncoding,      ///..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 session/process_prekey_impl()." [label="process_prekey_impl", tooltip=") -> Result<PreKeysUsed>  async fn process_prekey_impl(     message: &PreKeySignalMessage,     remote_address: &ProtocolAddress,     session_record: &mut SessionRecord,     signed_prekey_store: &dyn S..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidSenderKeySession#" [label="InvalidSenderKeySession", tooltip="    InvalidSenderKeySession  { distribution_id: Uuid },     /// session for {0} has invalid registration ID {1:X}     InvalidRegistrationId(crate::ProtocolAddress, u32),      /// message with old coun..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[PreKeySignalMessage][`TryFrom<&[u8]>`]try_from()." [label="try_from", tooltip="    fn try_from(value: &[u8]) -> Result<Self>  {         if value.is_empty() {             return Err(SignalProtocolError::CiphertextMessageTooShort(value.len()));         }          let message_versi..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/chunk_sizes_sha256()." [label="chunk_sizes_sha256", tooltip="    fn chunk_sizes_sha256()  {         for (data_size, expected) in [             (0, MINIMUM_CHUNK_SIZE),             (KIBIBYTES, MINIMUM_CHUNK_SIZE),             (10 * KIBIBYTES, MINIMUM_CHUNK_SIZE)..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderChainKey]new()." [label="new", tooltip="    pub(crate) fn new(iteration: u32, chain_key: Vec<u8>) -> Self  {         Self {             iteration,             chain_key,         }     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/get_or_create_chain_key()." [label="get_or_create_chain_key", tooltip="        Err(signal_crypto::DecryptionError::BadCiphertext(msg)) =>              ));         } {             log::warn!(' failed to decrypt 1:1 message: {}' , msg);             return Err(SignalProtoco..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessage#SignalMessage#" [label="SignalMessage", tooltip="pub enum CiphertextMessageType      SignalMessage(SignalMessage),     PreKeySignalMessage(PreKeySignalMessage),     SenderKeyMessage(SenderKeyMessage),     PlaintextContent(PlaintextContent), }  #[der..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/random_public_key()." [label="random_public_key", tooltip="    fn random_public_key() -> PublicKey  {         KeyPair::generate(&mut OsRng).public_key     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessage#SenderKeyMessage#" [label="SenderKeyMessage", tooltip="pub enum CiphertextMessageType      SenderKeyMessage(SenderKeyMessage),     PlaintextContent(PlaintextContent), }  #[derive(Copy, Clone, Eq, PartialEq, Debug, num_enum::TryFromPrimitive)] #[repr(u8)] ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/chunk_size_zero()." [label="chunk_size_zero", tooltip="    fn chunk_size_zero()  {         new_incremental(&[], 0);     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/aes_256_ctr_encrypt()." [label="aes_256_ctr_encrypt", tooltip="fn aes_256_ctr_encrypt(ptext: &[u8], key: &[u8]) -> Result<Vec<u8>, EncryptionError>  {     let key: [u8; 32] = key.try_into().map_err(|_| EncryptionError::BadKeyOrIv)?;      let zero_nonce = [0u8; 16..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[UnidentifiedSenderMessageContent]new()." [label="new", tooltip="    ) -> Result<Self>      pub fn new(         msg_type: CiphertextMessageType,         sender: SenderCertificate,         contents: Vec<u8>,         content_hint: ContentHint,         group_id: Optio..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/tests/test_raw_kem()." [label="test_raw_kem", tooltip="    fn test_raw_kem()  {         use pqcrypto_kyber::kyber1024::{decapsulate, encapsulate, keypair};         let (pk, sk) = keypair();         let (ss1, ct) = encapsulate(&pk);         let ss2 = decap..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/aes256_ctr_hmacsha256_decrypt()." [label="aes256_ctr_hmacsha256_decrypt", tooltip=") -> Result<Vec<u8>, DecryptionError>  pub(crate) fn aes256_ctr_hmacsha256_decrypt(     ctext: &[u8],     cipher_key: &[u8],     mac_key: &[u8], {     if ctext.len() < 10 {         return Err(Decrypti..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/when_second_state_with_same_public_key_and_chain_id_added_then_it_becomes_the_most_recent()." [label="when_second_state_with_same_public_key_and_chain_id_added_then_it_becomes_the_most_recent", tooltip="    fn when_second_state_with_same_public_key_and_chain_id_added_then_it_becomes_the_most_recent()  {         let mut context = TestContext::new();          let chain_id_1 = 1;         let chain_id_2 ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#FingerprintVersionMismatch#" [label="FingerprintVersionMismatch", tooltip="    /// bad key type <     FingerprintVersionMismatch(u32, u32),     /// fingerprint parsing error     FingerprintParsingError,      /// no key type identifier     NoKeyTypeIdentifier, {0:#04x}>     B..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/test_lossless_round_trip()." [label="test_lossless_round_trip", tooltip="fn test_lossless_round_trip() -> Result<()>  {     let trust_root = PrivateKey::deserialize(&[0u8; 32])?;      // To test a hypothetical addition of a new field:     //     // Step 1: temporarily add ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/total_digest_size()." [label="total_digest_size", tooltip="        fn total_digest_size(data_size: usize) -> usize  {             let chunk_size = calculate_chunk_size::<Sha256>(data_size);             let num_chunks = std::cmp::max(1, data_size.div_ceil(chun..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/DecryptionError#BadCiphertext#" [label="BadCiphertext", tooltip="fn aes_256_ctr_encrypt(ptext: &[u8], key: &[u8]) -> Result<Vec<u8>, EncryptionError>      BadCiphertext(&'static str), }  {     let key: [u8; 32] = key.try_into().map_err(|_| EncryptionError::BadKeyOr..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_signal_message_serialize_deserialize()." [label="test_signal_message_serialize_deserialize", tooltip="    fn test_signal_message_serialize_deserialize() -> Result<()>  {         let mut csprng = OsRng;         let message = create_signal_message(&mut csprng)?;         let deser_message =             S..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/total_digest_size_is_never_too_big()." [label="total_digest_size_is_never_too_big", tooltip="    fn total_digest_size_is_never_too_big()  {         fn total_digest_size(data_size: usize) -> usize {             let chunk_size = calculate_chunk_size::<Sha256>(data_size);             let num_chu..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/create_decryption_failure_log()." [label="create_decryption_failure_log", tooltip=") -> Result<String>  fn create_decryption_failure_log(     remote_address: &ProtocolAddress,     mut errs: &[SignalProtocolError],     record: &SessionRecord,     ciphertext: &SignalMessage, {     fn ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[Public][KeyKind]key_length()." [label="key_length", tooltip="    fn key_length(key_type: KeyType) -> usize  {         key_type.parameters().public_key_length()     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidPreKeyId#" [label="InvalidPreKeyId", tooltip="    /// invalid MAC key length <     InvalidPreKeyId,     /// invalid signed prekey identifier     InvalidSignedPreKeyId,     /// invalid Kyber prekey identifier     InvalidKyberPreKeyId,  {0}>     In..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKey]decode()." [label="decode", tooltip="    pub fn decode(value: &[u8]) -> Result<Self>  {         let pk = PublicKey::try_from(value)?;         Ok(Self { public_key: pk })     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[`UnidentifiedSenderMessage<'a>`]deserialize()." [label="deserialize", tooltip="    fn deserialize(data: &'a [u8]) -> Result<Self>  {         let (version_byte, remaining) = data.split_first().ok_or_else(|| {             SignalProtocolError::InvalidSealedSenderMessage(' Message w..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/create_signal_message()." [label="create_signal_message", tooltip="         fn create_signal_message<T>(csprng: &mut T) -> Result<SignalMessage>     where         T: Rng + CryptoRng, {         let mut mac_key = [0u8; 32];         csprng.fill_bytes(&mut mac_key);     ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/ContentHint#Resendable#" [label="Resendable", tooltip="impl ContentHint      Resendable,     Implicit,     Unknown(u32), }  {     fn to_proto(self) -> Option<i32> {         if self == ContentHint::Default {             None         } else {             So..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_decrypt_signal()." [label="message_decrypt_signal", tooltip=") -> Result<Vec<u8>>  pub async fn message_decrypt_signal<R: Rng + CryptoRng>(     ciphertext: &SignalMessage,     remote_address: &ProtocolAddress,     session_store: &mut dyn SessionStore,     ident..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 timestamp/impl#[Timestamp]from_epoch_millis()." [label="from_epoch_millis", tooltip="    pub const fn from_epoch_millis(milliseconds: u64) -> Self  {         Self(milliseconds)     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_encrypt()." [label="message_encrypt", tooltip=") -> Result<CiphertextMessage>  pub async fn message_encrypt(     ptext: &[u8],     remote_address: &ProtocolAddress,     session_store: &mut dyn SessionStore,     identity_store: &mut dyn IdentityKey..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[KeyPair]new()." [label="new", tooltip="    pub fn new(public_key: PublicKey, secret_key: SecretKey) -> Self  {         assert_eq!(public_key.key_type, secret_key.key_type);         Self {             public_key,             secret_key,    ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#NoSenderKeyState#" [label="NoSenderKeyState", tooltip="    NoSenderKeyState  { distribution_id: Uuid },      /// session with {0} not found     SessionNotFound(crate::ProtocolAddress),     /// invalid session: {0}     InvalidSessionStructure(&'static str)..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#DuplicatedMessage#" [label="DuplicatedMessage", tooltip="    /// invalid      DuplicatedMessage(u32, u32), {0:?} message: {1}     InvalidMessage(crate::CiphertextMessageType, &'static str),      /// error while invoking an ffi callback: {0}     FfiBindingEr..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/hmac_sha256()." [label="hmac_sha256", tooltip="pub(crate) fn hmac_sha256(key: &[u8], input: &[u8]) -> [u8; 32]  {     let mut hmac =         Hmac::<Sha256>::new_from_slice(key).expect(' HMAC-SHA256 should accept any size key' );     hmac.update(in..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 session/impl#[PreKeysUsed][Default]default()." [label="default", tooltip=""]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[CiphertextMessageType][`From<ProtoMessageType>`]from()." [label="from", tooltip="    fn from(message_type: ProtoMessageType) -> Self  {         let result = match message_type {             ProtoMessageType::Message => Self::Whisper,             ProtoMessageType::PrekeyMessage => ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#LegacyCiphertextVersion#" [label="LegacyCiphertextVersion", tooltip="    /// ciphertext version was unrecognized <     LegacyCiphertextVersion(u8), {0}>     UnrecognizedCiphertextVersion(u8),     /// unrecognized message version <{0}>     UnrecognizedMessageVersion(u32..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/initialize_bob_session_record()." [label="initialize_bob_session_record", tooltip=") -> Result<SessionRecord>  pub fn initialize_bob_session_record(     parameters: &BobSignalProtocolParameters, {     Ok(SessionRecord::new(initialize_bob_session(parameters)?)) }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/impl#[Fingerprint]new()." [label="new", tooltip="    ) -> Result<Fingerprint>      pub fn new(         version: u32,         iterations: u32,         local_id: &[u8],         local_key: &IdentityKey,         remote_id: &[u8],         remote_key: &Id..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#SealedSenderSelfSend#" [label="SealedSenderSelfSend", tooltip="    /// bad KEM key type <     SealedSenderSelfSend,  {0:#04x}>     BadKEMKeyType(u8),     /// unexpected KEM key type <{0:#04x}> (expected <{1:#04x}>)     WrongKEMKeyType(u8, u8),     /// bad KEM key..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_sender_key_message_serialize_deserialize()." [label="test_sender_key_message_serialize_deserialize", tooltip="    fn test_sender_key_message_serialize_deserialize() -> Result<()>  {         let mut csprng = OsRng;         let signature_key_pair = KeyPair::generate(&mut csprng);         let sender_key_message ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_decryption_error_message()." [label="test_decryption_error_message", tooltip="    fn test_decryption_error_message() -> Result<()>  {         let mut csprng = OsRng;         let identity_key_pair = KeyPair::generate(&mut csprng);         let base_key_pair = KeyPair::generate(&m..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[SenderCertificate]deserialize()." [label="deserialize", tooltip="    pub fn deserialize(data: &[u8]) -> Result<Self>  {         let pb = proto::sealed_sender::SenderCertificate::decode(data)             .map_err(|_| SignalProtocolError::InvalidProtobufEncoding)?;  ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/tests/test_kyber1024_keypair()." [label="test_kyber1024_keypair", tooltip="    fn test_kyber1024_keypair()  {         let kp = KeyPair::generate(KeyType::Kyber1024);         assert_eq!(             kyber1024::Parameters::SECRET_KEY_LENGTH + 1,             kp.secret_key.seria..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#CiphertextMessageTooShort#" [label="CiphertextMessageTooShort", tooltip="    /// ciphertext version was too old <     CiphertextMessageTooShort(usize), {0}>     LegacyCiphertextVersion(u8),     /// ciphertext version was unrecognized <{0}>     UnrecognizedCiphertextVersion..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#UntrustedIdentity#" [label="UntrustedIdentity", tooltip="    /// invalid MAC key length <     UntrustedIdentity(crate::ProtocolAddress),      /// invalid prekey identifier     InvalidPreKeyId,     /// invalid signed prekey identifier     InvalidSignedPreKey..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Ciphertext<'a>`]deserialize()." [label="deserialize", tooltip="    pub fn deserialize(value: &'a [u8]) -> Result<Self>  {         if value.is_empty() {             return Err(SignalProtocolError::NoKeyTypeIdentifier);         }         let key_type = KeyType::try..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderKeyState]new()." [label="new", tooltip="    ) -> SenderKeyState      pub(crate) fn new(         message_version: u8,         chain_id: u32,         iteration: u32,         chain_key: &[u8],         signature_key: PublicKey,         signatur..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/advance()." [label="advance", tooltip="        fn advance<'a, const N: usize>(buf: &mut &'a [u8]) -> Result<&'a [u8; N]>  {             if N > buf.len() {                 return Err(SignalProtocolError::InvalidProtobufEncoding);           ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/validating_simple_test()." [label="validating_simple_test", tooltip="    fn validating_simple_test()  {         let key = TEST_HMAC_KEY;         let input = ' this is a simple test input string' ;          let bytes = input.as_bytes();         let mut incremental = new..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#UnrecognizedMessageVersion#" [label="UnrecognizedMessageVersion", tooltip="    /// fingerprint version number mismatch them      UnrecognizedMessageVersion(u32),  {0} us {1}     FingerprintVersionMismatch(u32, u32),     /// fingerprint parsing error     FingerprintParsingErr..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/tests/test_kyber1024_kem()." [label="test_kyber1024_kem", tooltip="    fn test_kyber1024_kem()  {         // test data for kyber1024         let pk_bytes = include_bytes!(' kem/test-data/pk.dat' );         let sk_bytes = include_bytes!(' kem/test-data/sk.dat' );     ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_multi_recipient_encrypt_impl()." [label="sealed_sender_multi_recipient_encrypt_impl", tooltip="async fn sealed_sender_multi_recipient_encrypt_impl<     R: Rng + CryptoRng,     X: IntoIterator<Item = ServiceId>, >(     destinations: &[&ProtocolAddress],     destination_sessions: &[&SessionRecord..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderKeyRecord]new_empty()." [label="new_empty", tooltip="    pub(crate) fn new_empty() -> Self  {         Self {             states: VecDeque::with_capacity(consts::MAX_SENDER_KEY_STATES),         }     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[PlaintextContent][`From<DecryptionErrorMessage>`]from()." [label="from", tooltip="    fn from(message: DecryptionErrorMessage) -> Self  {         let proto_structure = proto::service::Content {             decryption_error_message: Some(message.serialized().to_vec()),             ...."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/impl#[TestContext]new()." [label="new", tooltip="        fn new() -> Self  {             Self {                 sender_key_record: SenderKeyRecord::new_empty(),             }         }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v1/impl#[StaticKeys]calculate()." [label="calculate", tooltip="        ) -> Result<Self>          pub(super) fn calculate(             our_keys: &IdentityKeyPair,             their_key: &PublicKey,             chain_key: &[u8; 32],             ctext: &[u8], {    ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/simple_test()." [label="simple_test", tooltip="    fn simple_test()  {         let key = TEST_HMAC_KEY;         let input = ' this is a simple test input string which is longer than the chunk' ;          let bytes = input.as_bytes();         let e..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/validating_returns_right_size()." [label="validating_returns_right_size", tooltip="    fn validating_returns_right_size()  {         let key = TEST_HMAC_KEY;         let input = ' this is a simple test input string' ;          let bytes = input.as_bytes();         let mut incrementa..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/test/fingerprint_test_v2()." [label="fingerprint_test_v2", tooltip="    fn fingerprint_test_v2() -> Result<()>  {         // testVectorsVersion2 in Java          let a_key = IdentityKey::decode(ALICE_IDENTITY)?;         let b_key = IdentityKey::decode(BOB_IDENTITY)?; ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/read5_mod_100k()." [label="read5_mod_100k", tooltip="    fn read5_mod_100k(fprint: &[u8]) -> u64  {         assert_eq!(fprint.len(), 5);         let x = fprint.iter().fold(0u64, |acc, &x| (acc << 8) | (x as u64));         x % 100_000     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[DecryptionErrorMessage]for_original()." [label="for_original", tooltip="    ) -> Result<Self>      pub fn for_original(         original_bytes: &[u8],         original_type: CiphertextMessageType,         original_timestamp: Timestamp,         original_sender_device_id: u..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[DecryptionErrorMessage][`TryFrom<&[u8]>`]try_from()." [label="try_from", tooltip="    fn try_from(value: &[u8]) -> Result<Self>  {         let proto_structure = proto::service::DecryptionErrorMessage::decode(value)             .map_err(|_| SignalProtocolError::InvalidProtobufEncodi..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessage#PlaintextContent#" [label="PlaintextContent", tooltip="pub enum CiphertextMessageType      PlaintextContent(PlaintextContent), }  #[derive(Copy, Clone, Eq, PartialEq, Debug, num_enum::TryFromPrimitive)] #[repr(u8)] {     Whisper = 2,     PreKey = 3,     S..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/initialize_bob_session()." [label="initialize_bob_session", tooltip=") -> Result<SessionState>  pub(crate) fn initialize_bob_session(     parameters: &BobSignalProtocolParameters, {     let local_identity = parameters.our_identity_key_pair().identity_key();      let mu..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SignalMessage][`TryFrom<&[u8]>`]try_from()." [label="try_from", tooltip="    fn try_from(value: &[u8]) -> Result<Self>  {         if value.len() < SignalMessage::MAC_LENGTH + 1 {             return Err(SignalProtocolError::CiphertextMessageTooShort(value.len()));         }..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SenderKeyMessage]new()." [label="new", tooltip="    ) -> Result<Self>      pub fn new<R: CryptoRng + Rng>(         message_version: u8,         distribution_id: Uuid,         chain_id: u32,         iteration: u32,         ciphertext: Box<[u8]>,    ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Key<Public>`][`TryFrom<&[u8]>`]try_from()." [label="try_from", tooltip="    fn try_from(value: &[u8]) -> Result<Self>  {         Self::deserialize(value)     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/initialize_alice_session()." [label="initialize_alice_session", tooltip=") -> Result<SessionState>  pub(crate) fn initialize_alice_session<R: Rng + CryptoRng>(     parameters: &AliceSignalProtocolParameters,     mut csprng: &mut R, {     let local_identity = parameters.our..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/when_exceed_maximum_states_then_oldest_is_ejected()." [label="when_exceed_maximum_states_then_oldest_is_ejected", tooltip="    fn when_exceed_maximum_states_then_oldest_is_ejected()  {         assert_eq!(             5,             consts::MAX_SENDER_KEY_STATES,             ' Test written to expect this limit'          );..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[Secret][KeyKind]key_length()." [label="key_length", tooltip="    fn key_length(key_type: KeyType) -> usize  {         key_type.parameters().secret_key_length()     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SignalMessage]compute_mac()." [label="compute_mac", tooltip="    ) -> Result<[u8; Self::MAC_LENGTH]>      fn compute_mac(         sender_identity_key: &IdentityKey,         receiver_identity_key: &IdentityKey,         mac_key: &[u8],         message: &[u8], {  ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[SenderCertificate]new()." [label="new", tooltip="    ) -> Result<Self>      pub fn new<R: Rng + CryptoRng>(         sender_uuid: String,         sender_e164: Option<String>,         key: PublicKey,         sender_device_id: DeviceId,         expirat..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[ProtoMessageType][`From<CiphertextMessageType>`]from()." [label="from", tooltip="    fn from(message_type: CiphertextMessageType) -> Self  {         let result = match message_type {             CiphertextMessageType::PreKey => Self::PrekeyMessage,             CiphertextMessageTyp..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#WrongKEMKeyType#" [label="WrongKEMKeyType", tooltip="    /// bad KEM key length <     WrongKEMKeyType(u8, u8), {1}> for key with type <{0}>     BadKEMKeyLength(kem::KeyType, usize),     /// bad KEM ciphertext length <{1}> for key with type <{0}>     Bad..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderMessageKey]from_protobuf()." [label="from_protobuf", tooltip="    ) -> Self      pub(crate) fn from_protobuf(         smk: storage_proto::sender_key_state_structure::SenderMessageKey, {         Self::new(smk.iteration, smk.seed)     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/apply_agreement_xor()." [label="apply_agreement_xor", tooltip="    ) -> Result<[u8; MESSAGE_KEY_LEN]>      pub(super) fn apply_agreement_xor(         our_keys: &KeyPair,         their_key: &PublicKey,         direction: Direction,         input: &[u8; MESSAGE_KEY..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_decrypt()." [label="message_decrypt", tooltip=") -> Result<Vec<u8>>  pub async fn message_decrypt<R: Rng + CryptoRng>(     ciphertext: &CiphertextMessage,     remote_address: &ProtocolAddress,     session_store: &mut dyn SessionStore,     identity..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/get_or_create_message_key()." [label="get_or_create_message_key", tooltip="    let previous_index = if current_index > 0       state.set_root_key(&sender_chain.0);     state.add_receiver_chain(their_ephemeral, &receiver_chain.1);      let current_index = state.get_sender_cha..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidSealedSenderMessage#" [label="InvalidSealedSenderMessage", tooltip="    /// unknown sealed sender message version      InvalidSealedSenderMessage(String), {0}     UnknownSealedSenderVersion(u8),     /// self send of a sealed sender message     SealedSenderSelfSend,   ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#SenderKey#" [label="SenderKey", tooltip="impl CiphertextMessage      SenderKey = 7,     Plaintext = 8, }  {     pub fn message_type(&self) -> CiphertextMessageType {         match self {             CiphertextMessage::SignalMessage(_) => Cip..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#BadKEMKeyType#" [label="BadKEMKeyType", tooltip="    /// unexpected KEM key type <     BadKEMKeyType(u8), {0:#04x}> (expected <{1:#04x}>)     WrongKEMKeyType(u8, u8),     /// bad KEM key length <{1}> for key with type <{0}>     BadKEMKeyLength(kem::..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/when_second_state_with_same_public_key_and_chain_id_added_then_it_keeps_first_data()." [label="when_second_state_with_same_public_key_and_chain_id_added_then_it_keeps_first_data", tooltip="    fn when_second_state_with_same_public_key_and_chain_id_added_then_it_keeps_first_data()  {         let mut context = TestContext::new();          let chain_id = 1;         let record_key = (random..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/impl#[SignalProtocolError][`From<CurveError>`]from()." [label="from", tooltip="    fn from(e: CurveError) -> Self  {         match e {             CurveError::NoKeyTypeIdentifier => Self::NoKeyTypeIdentifier,             CurveError::BadKeyType(raw) => Self::BadKeyType(raw),     ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/test/fingerprint_mismatching_fingerprints()." [label="fingerprint_mismatching_fingerprints", tooltip="    fn fingerprint_mismatching_fingerprints() -> Result<()>  {         use rand::rngs::OsRng;          use crate::IdentityKeyPair;          let a_key_pair = IdentityKeyPair::generate(&mut OsRng);     ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_chain_key_iteration_tests/when_sender_chain_key_iteration_overflows()." [label="when_sender_chain_key_iteration_overflows", tooltip="    fn when_sender_chain_key_iteration_overflows()  {         let sender_chain_key: SenderChainKey =             SenderChainKey::new(u32::MAX, INITIAL_SEED_KEY.to_vec());         assert_matches!(     ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKey][`From<PublicKey>`]from()." [label="from", tooltip=""]
    "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_encrypt()." [label="sealed_sender_encrypt", tooltip=") -> Result<Vec<u8>>  pub async fn sealed_sender_encrypt<R: Rng + CryptoRng>(     destination: &ProtocolAddress,     sender_cert: &SenderCertificate,     ptext: &[u8],     session_store: &mut dyn Sess..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#BadKeyType#" [label="BadKeyType", tooltip="    /// bad key length <     BadKeyType(u8), {1}> for key with type <{0}>     BadKeyLength(KeyType, usize),      /// invalid signature detected     SignatureValidationFailed,      /// untrusted identi..."]
  }
  subgraph cluster_1 {
    label = "/home/lacra/git_repos/libsignal/rust/protocol/src/kem";
    style=filled;
    color=lightgrey;
    fontname=Helvetica;
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/kyber1024/impl#[Parameters][Parameters]encapsulate()." [label="encapsulate", tooltip="    fn encapsulate(pub_key: &KeyMaterial<Public>) -> (super::SharedSecret, super::RawCiphertext)  {         let kyber_pk = pqcrypto_kyber::kyber1024::PublicKey::from_bytes(pub_key)             .expect..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/kyber768/impl#[Parameters][Parameters]decapsulate()." [label="decapsulate", tooltip="    ) -> Result<super::SharedSecret>      fn decapsulate(         secret_key: &KeyMaterial<Secret>,         ciphertext: &[u8], {         let kyber_sk = pqcrypto_kyber::kyber768::SecretKey::from_bytes(..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/kyber1024/impl#[Parameters][Parameters]decapsulate()." [label="decapsulate", tooltip="    ) -> Result<super::SharedSecret>      fn decapsulate(         secret_key: &KeyMaterial<Secret>,         ciphertext: &[u8], {         let kyber_sk = pqcrypto_kyber::kyber1024::SecretKey::from_bytes..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/kyber768/impl#[Parameters][Parameters]encapsulate()." [label="encapsulate", tooltip="    fn encapsulate(pub_key: &KeyMaterial<Public>) -> (super::SharedSecret, super::RawCiphertext)  {         let kyber_pk = pqcrypto_kyber::kyber768::PublicKey::from_bytes(pub_key)             .expect(..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/kyber768/impl#[Parameters][Parameters]generate()." [label="generate", tooltip="    fn generate() -> (KeyMaterial<Public>, KeyMaterial<Secret>)  {         let (pk, sk) = pqcrypto_kyber::kyber768::keypair();         (             KeyMaterial::new(pk.as_bytes().into()),            ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 kem/kyber1024/impl#[Parameters][Parameters]generate()." [label="generate", tooltip="    fn generate() -> (KeyMaterial<Public>, KeyMaterial<Secret>)  {         let (pk, sk) = pqcrypto_kyber::kyber1024::keypair();         (             KeyMaterial::new(pk.as_bytes().into()),           ..."]
  }
  subgraph cluster_2 {
    label = "/home/lacra/git_repos/libsignal/rust/protocol/src/ratchet";
    style=filled;
    color=lightgrey;
    fontname=Helvetica;
    "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/MessageKeyGenerator#Keys#" [label="Keys", tooltip="impl MessageKeyGenerator      Keys(MessageKeys),     Seed((Vec<u8>, u32)), }  {     pub(crate) fn new_from_seed(seed: &[u8], counter: u32) -> Self {         Self::Seed((seed.to_vec(), counter))     } ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/params/impl#[`BobSignalProtocolParameters<'a>`]new()." [label="new", tooltip="    ) -> Self      pub fn new(         our_identity_key_pair: IdentityKeyPair,         our_signed_pre_key_pair: KeyPair,         our_one_time_pre_key_pair: Option<KeyPair>,         our_ratchet_key_pai..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/impl#[ChainKey]new()." [label="new", tooltip="    pub(crate) fn new(key: [u8; 32], index: u32) -> Self  {         Self { key, index }     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/MessageKeyGenerator#Seed#" [label="Seed", tooltip="impl MessageKeyGenerator      Seed((Vec<u8>, u32)), }  {     pub(crate) fn new_from_seed(seed: &[u8], counter: u32) -> Self {         Self::Seed((seed.to_vec(), counter))     }     pub(crate) fn gener..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/tests/test_chain_key_derivation()." [label="test_chain_key_derivation", tooltip="    fn test_chain_key_derivation() -> Result<()>  {         let seed = [             0x8au8, 0xb7, 0x2d, 0x6f, 0x4c, 0xc5, 0xac, 0x0d, 0x38, 0x7e, 0xaf, 0x46, 0x33, 0x78,             0xdd, 0xb2, 0x8e,..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/impl#[MessageKeys]derive_keys()." [label="derive_keys", tooltip="    pub(crate) fn derive_keys(input_key_material: &[u8], counter: u32) -> Self  {         let mut okm = [0; 80];         hkdf::Hkdf::<sha2::Sha256>::new(None, input_key_material)             .expand(b..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/impl#[MessageKeyGenerator]new_from_seed()." [label="new_from_seed", tooltip="    pub(crate) fn new_from_seed(seed: &[u8], counter: u32) -> Self  {         Self::Seed((seed.to_vec(), counter))     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/impl#[RootKey]new()." [label="new", tooltip="    pub(crate) fn new(key: [u8; 32]) -> Self  {         Self { key }     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/impl#[MessageKeyGenerator]from_pb()." [label="from_pb", tooltip="    ) -> std::result::Result<Self, &'static str>      pub(crate) fn from_pb(         pb: session_structure::chain::MessageKey, {         Ok(if pb.seed.is_empty() {             Self::Keys(MessageKeys {..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/params/impl#[AliceSignalProtocolParameters]new()." [label="new", tooltip="    ) -> Self      pub fn new(         our_identity_key_pair: IdentityKeyPair,         our_base_key_pair: KeyPair,         their_identity_key: IdentityKey,         their_signed_pre_key: PublicKey,    ..."]
  }
  subgraph cluster_3 {
    label = "/home/lacra/git_repos/libsignal/rust/protocol/src/state";
    style=filled;
    color=lightgrey;
    fontname=Helvetica;
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/prekey/impl#[PreKeyRecord]new()." [label="new", tooltip="    pub fn new(id: PreKeyId, key: &KeyPair) -> Self  {         let public_key = key.public_key.serialize().to_vec();         let private_key = key.private_key.serialize().to_vec();         Self {     ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SessionState][`From<SessionStructure>`]from()." [label="from", tooltip="    fn from(value: SessionStructure) -> SessionState  {         SessionState::from_session_structure(value)     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/GenericSignedPreKey#deserialize()." [label="deserialize", tooltip="         fn deserialize(data: &[u8]) -> Result<Self>     where         Self: Sized, {         Ok(Self::from_storage(             SignedPreKeyRecordStructure::decode(data)                 .map_err(|_| ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/bundle/impl#[PreKeyBundle]new()." [label="new", tooltip="    ) -> Result<Self>      pub fn new(         registration_id: u32,         device_id: DeviceId,         pre_key: Option<(PreKeyId, PublicKey)>,         signed_pre_key_id: SignedPreKeyId,         sig..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/kyber_prekey/impl#[KyberPreKeyRecord]generate()." [label="generate", tooltip="    ) -> Result<KyberPreKeyRecord>      pub fn generate(         kyber_key_type: kem::KeyType,         id: KyberPreKeyId,         signing_key: &PrivateKey, {         let key_pair = kem::KeyPair::gener..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SessionState]from_session_structure()." [label="from_session_structure", tooltip="    pub(crate) fn from_session_structure(session: SessionStructure) -> Self  {         Self { session }     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/impl#[`kem::Key<kem::Public>`][KeySerde]deserialize()." [label="deserialize", tooltip="         fn deserialize<T: AsRef<[u8]>>(bytes: T) -> Result<Self>     where         Self: Sized, {         Self::deserialize(bytes.as_ref())     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/KeyPairSerde#from_public_and_private()." [label="from_public_and_private", tooltip="impl KeySerde for PublicKey      fn from_public_and_private(public_key: &[u8], private_key: &[u8]) -> Result<Self>     where         Self: Sized;     fn get_public(&self) -> &Self::PublicKey;     fn g..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/KeySerde#deserialize()." [label="deserialize", tooltip="pub trait KeyPairSerde      fn deserialize<T: AsRef<[u8]>>(bytes: T) -> Result<Self>     where         Self: Sized; }  {     type PublicKey: KeySerde;     type PrivateKey: KeySerde;     fn from_public..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/bundle/impl#[PreKeyBundle][`TryFrom<PreKeyBundleContent>`]try_from()." [label="try_from", tooltip="    fn try_from(content: PreKeyBundleContent) -> Result<Self>  {         let mut bundle = PreKeyBundle::new(             content.registration_id.ok_or_else(|| {                 SignalProtocolError::In..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/bundle/impl#[SignedPreKey]new()." [label="new", tooltip="    fn new(id: SignedPreKeyId, public_key: PublicKey, signature: Vec<u8>) -> Self  {         Self {             id,             public_key,             signature,         }     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/impl#[SignedPreKeyRecord][GenericSignedPreKey]from_storage()." [label="from_storage", tooltip="    fn from_storage(storage: SignedPreKeyRecordStructure) -> Self  {         Self {             signed_pre_key: storage,         }     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/GenericSignedPreKey#new()." [label="new", tooltip="         fn new(id: Self::Id, timestamp: Timestamp, key_pair: &Self::KeyPair, signature: &[u8]) -> Self     where         Self: Sized, {         let timestamp = timestamp.epoch_millis();         let p..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SessionStructure][`From<SessionState>`]from()." [label="from", tooltip="    fn from(value: SessionState) -> SessionStructure  {         value.session     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/kyber_prekey/impl#[KyberPreKeyRecord][GenericSignedPreKey]from_storage()." [label="from_storage", tooltip="    fn from_storage(storage: SignedPreKeyRecordStructure) -> Self  {         Self {             signed_pre_key: storage,         }     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/impl#[KeyPair][KeyPairSerde]from_public_and_private()." [label="from_public_and_private", tooltip="    fn from_public_and_private(public_key: &[u8], private_key: &[u8]) -> Result<Self>  {         Ok(KeyPair::from_public_and_private(public_key, private_key)?)     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SessionState]new()." [label="new", tooltip="    ) -> Self      pub(crate) fn new(         version: u8,         our_identity: &IdentityKey,         their_identity: &IdentityKey,         root_key: &RootKey,         alice_base_key: &PublicKey, {  ..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/bundle/impl#[KyberPreKey]new()." [label="new", tooltip="    fn new(id: KyberPreKeyId, public_key: kem::PublicKey, signature: Vec<u8>) -> Self  {         Self {             id,             public_key,             signature,         }     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/bundle/zip3()." [label="zip3", tooltip="        fn zip3<T, U, V>(x: Option<T>, y: Option<U>, z: Option<V>) -> Option<(T, U, V)>  {             x.zip(y).zip(z).map(|((x, y), z)| (x, y, z))         }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/impl#[PublicKey][KeySerde]deserialize()." [label="deserialize", tooltip="    fn deserialize<T: AsRef<[u8]>>(bytes: T) -> Result<Self>  {         Ok(Self::deserialize(bytes.as_ref())?)     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/impl#[`kem::KeyPair`][KeyPairSerde]from_public_and_private()." [label="from_public_and_private", tooltip="    fn from_public_and_private(public_key: &[u8], private_key: &[u8]) -> Result<Self>  {         kem::KeyPair::from_public_and_private(public_key, private_key)     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SignalProtocolError][`From<InvalidSessionError>`]from()." [label="from", tooltip="    fn from(e: InvalidSessionError) -> Self  {         Self::InvalidSessionStructure(e.0)     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/impl#[PrivateKey][KeySerde]deserialize()." [label="deserialize", tooltip="    fn deserialize<T: AsRef<[u8]>>(bytes: T) -> Result<Self>  {         Ok(Self::deserialize(bytes.as_ref())?)     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SessionRecord]new()." [label="new", tooltip="    pub(crate) fn new(state: SessionState) -> Self  {         Self {             current_session: Some(state),             previous_sessions: Vec::new(),         }     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/prekey/impl#[PreKeyRecord]deserialize()." [label="deserialize", tooltip="    pub fn deserialize(data: &[u8]) -> Result<Self>  {         Ok(Self {             pre_key: PreKeyRecordStructure::decode(data)                 .map_err(|_| SignalProtocolError::InvalidProtobufEncod..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/bundle/impl#[PreKeyBundleContent][`From<PreKeyBundle>`]from()." [label="from", tooltip="    fn from(bundle: PreKeyBundle) -> Self  {         Self {             registration_id: Some(bundle.registration_id),             device_id: Some(bundle.device_id),             pre_key_id: bundle.pre..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SessionStructure][`From<&SessionState>`]from()." [label="from", tooltip="    fn from(value: &SessionState) -> SessionStructure  {         value.session.clone()     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[`UnacknowledgedPreKeyMessageItems<'a>`]new()." [label="new", tooltip="    ) -> Self      fn new(         pre_key_id: Option<PreKeyId>,         signed_pre_key_id: SignedPreKeyId,         base_key: PublicKey,         pending_kyber_pre_key: Option<&'a session_structure::Pe..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/GenericSignedPreKey#from_storage()." [label="from_storage", tooltip="         fn from_storage(storage: SignedPreKeyRecordStructure) -> Self;      fn new(id: Self::Id, timestamp: Timestamp, key_pair: &Self::KeyPair, signature: &[u8]) -> Self     where         Self: Size..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SessionRecord]new_fresh()." [label="new_fresh", tooltip="    pub fn new_fresh() -> Self  {         Self {             current_session: None,             previous_sessions: Vec::new(),         }     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/impl#[`kem::Key<kem::Secret>`][KeySerde]deserialize()." [label="deserialize", tooltip="         fn deserialize<T: AsRef<[u8]>>(bytes: T) -> Result<Self>     where         Self: Sized, {         Self::deserialize(bytes.as_ref())     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SessionRecord]deserialize()." [label="deserialize", tooltip="    pub fn deserialize(bytes: &[u8]) -> Result<Self, SignalProtocolError>  {         let record = RecordStructure::decode(bytes)             .map_err(|_| InvalidSessionError(' failed to decode session..."]
  }
  subgraph cluster_4 {
    label = "/home/lacra/git_repos/libsignal/rust/protocol/src/storage";
    style=filled;
    color=lightgrey;
    fontname=Helvetica;
    "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSenderKeyStore][Default]default()." [label="default", tooltip="    fn default() -> Self  {         Self::new()     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSignedPreKeyStore]new()." [label="new", tooltip="    pub fn new() -> Self  {         Self {             signed_pre_keys: HashMap::new(),         }     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemKyberPreKeyStore][Default]default()." [label="default", tooltip="    fn default() -> Self  {         Self::new()     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSessionStore][Default]default()." [label="default", tooltip="    fn default() -> Self  {         Self::new()     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemPreKeyStore][Default]default()." [label="default", tooltip="    fn default() -> Self  {         Self::new()     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemKyberPreKeyStore]new()." [label="new", tooltip="    pub fn new() -> Self  {         Self {             kyber_pre_keys: HashMap::new(),         }     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 storage/traits/Direction#Receiving#" [label="Receiving", tooltip="pub trait IdentityKeyStore      Receiving, }  /// Interface defining the identity store, which may be in-memory, on-disk, etc. /// /// Signal clients usually use the identity store in a [TOFU] manner,..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSignalProtocolStore]new()." [label="new", tooltip="    pub fn new(key_pair: IdentityKeyPair, registration_id: u32) -> Result<Self>  {         Ok(Self {             session_store: InMemSessionStore::new(),             pre_key_store: InMemPreKeyStore::n..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemIdentityKeyStore]new()." [label="new", tooltip="    pub fn new(key_pair: IdentityKeyPair, registration_id: u32) -> Self  {         Self {             key_pair,             registration_id,             known_keys: HashMap::new(),         }     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSignedPreKeyStore][Default]default()." [label="default", tooltip="    fn default() -> Self  {         Self::new()     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSenderKeyStore]new()." [label="new", tooltip="    pub fn new() -> Self  {         Self {             keys: HashMap::new(),         }     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 storage/traits/Direction#Sending#" [label="Sending", tooltip="pub trait IdentityKeyStore      Sending,     /// We are in the context of receiving a message.     Receiving, }  /// Interface defining the identity store, which may be in-memory, on-disk, etc. /// //..."]
    "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemPreKeyStore]new()." [label="new", tooltip="    pub fn new() -> Self  {         Self {             pre_keys: HashMap::new(),         }     }"]
    "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSessionStore]new()." [label="new", tooltip="    pub fn new() -> Self  {         Self {             sessions: HashMap::new(),         }     }"]
  }

  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/CurrentOrPrevious#Previous#" -> "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/CurrentOrPrevious#Current#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 error/impl#[SignalProtocolError]for_application_callback()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#ApplicationCallbackError#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSenderKeyStore][Default]default()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSenderKeyStore]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 session/process_prekey()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 session/process_prekey_impl()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 session/process_prekey()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/traits/Direction#Receiving#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session/process_prekey()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#UntrustedIdentity#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v1/test_agreement_and_authentication()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/aes256_ctr_hmacsha256_decrypt()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v1/test_agreement_and_authentication()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v1/impl#[StaticKeys]calculate()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v1/test_agreement_and_authentication()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/traits/Direction#Receiving#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v1/test_agreement_and_authentication()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/aes256_ctr_hmacsha256_encrypt()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v1/test_agreement_and_authentication()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKeyPair]generate()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v1/test_agreement_and_authentication()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v1/impl#[EphemeralKeys]calculate()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v1/test_agreement_and_authentication()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/traits/Direction#Sending#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/decrypt_message_with_state()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/get_or_create_chain_key()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/decrypt_message_with_state()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/get_or_create_message_key()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/decrypt_message_with_state()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidSessionStructure#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/decrypt_message_with_state()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidMessage#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/decrypt_message_with_state()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#UnrecognizedMessageVersion#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/ContentHint#Unknown#" -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/ContentHint#Implicit#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/ContentHint#Unknown#" -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/ContentHint#Default#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/ContentHint#Unknown#" -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[u32][`From<ContentHint>`]from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/ContentHint#Unknown#" -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/ContentHint#Resendable#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/group_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#UnrecognizedMessageVersion#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/group_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#SignatureValidationFailed#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/group_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidSenderKeySession#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/group_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidMessage#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/group_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/get_sender_key()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/group_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SenderKeyMessage][`TryFrom<&[u8]>`]try_from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/group_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#NoSenderKeyState#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/group_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#SenderKey#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/tests/test_kyber768_keypair()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/KeyType#Kyber768#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/tests/test_kyber768_keypair()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[KeyPair]generate()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/test/fingerprint_matching_identifiers()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/impl#[Fingerprint]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/test/fingerprint_matching_identifiers()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKeyPair]generate()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[KeyType][`TryFrom<u8>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/KeyType#Kyber1024#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[KeyType][`TryFrom<u8>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/KeyType#Kyber768#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[KeyType][`TryFrom<u8>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#BadKEMKeyType#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemKyberPreKeyStore][Default]default()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidKyberPreKeyId#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemKyberPreKeyStore][Default]default()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemKyberPreKeyStore]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/produce_and_validate()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/new_incremental()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/chunk_sizes_sha512()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/calculate_chunk_size()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/derive_keys_with_label()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/impl#[RootKey]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/derive_keys_with_label()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/impl#[ChainKey]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/final_result_should_be_equal_to_non_incremental_hmac()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/hmac_sha256()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/final_result_should_be_equal_to_non_incremental_hmac()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/new_incremental()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SessionState][`From<SessionStructure>`]from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SessionState]from_session_structure()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/incremental_macs_are_valid()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/new_incremental()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/incremental_macs_are_valid()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/hmac_sha256()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKeyPair][`TryFrom<PrivateKey>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKey]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKeyPair][`TryFrom<PrivateKey>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKeyPair]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/tests/test_identity_key_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKey][`From<PublicKey>`]from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[PlaintextContent][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#UnrecognizedMessageVersion#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[PlaintextContent][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#CiphertextMessageTooShort#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/tests/test_alternate_identity_signing()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKeyPair]generate()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSessionStore][Default]default()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSessionStore]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/process_sender_key_distribution_message()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderKeyRecord]new_empty()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/test_agreement_and_authentication()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/traits/Direction#Receiving#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/test_agreement_and_authentication()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/apply_agreement_xor()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/test_agreement_and_authentication()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKeyPair]generate()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/test_agreement_and_authentication()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/compute_authentication_tag()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/test_agreement_and_authentication()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/impl#[DerivedKeys]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/test_agreement_and_authentication()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/traits/Direction#Sending#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/create_sender_key_distribution_message()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderKeyRecord]new_empty()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/create_sender_key_distribution_message()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SenderKeyDistributionMessage]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/create_sender_key_distribution_message()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidSenderKeySession#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/get_encoded_string()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidArgument#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[UnidentifiedSenderMessageContent]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[ContentHint][`From<u32>`]from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[UnidentifiedSenderMessageContent]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidProtobufEncoding#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[UnidentifiedSenderMessageContent]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/ContentHint#Default#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[UnidentifiedSenderMessageContent]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[CiphertextMessageType][`From<ProtoMessageType>`]from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[UnidentifiedSenderMessageContent]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[SenderCertificate]deserialize()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/GenericSignedPreKey#deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidProtobufEncoding#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/GenericSignedPreKey#deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 timestamp/impl#[Timestamp]from_epoch_millis()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/GenericSignedPreKey#deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/KeySerde#deserialize()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/GenericSignedPreKey#deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/KeyPairSerde#from_public_and_private()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/GenericSignedPreKey#deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/GenericSignedPreKey#from_storage()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/impl#[DisplayableFingerprint]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/get_encoded_string()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/impl#[ScannableFingerprint]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#FingerprintParsingError#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/impl#[ScannableFingerprint]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#FingerprintVersionMismatch#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/impl#[Fingerprint]get_fingerprint()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidArgument#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/test/aes_ctr_test()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/aes_256_ctr_encrypt()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/KeyType#Kyber1024#" -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/KeyType#Kyber768#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/bundle/impl#[PreKeyBundle]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 state/bundle/impl#[SignedPreKey]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/bundle/impl#[PreKeyBundle]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 state/bundle/impl#[KyberPreKey]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/kyber_prekey/impl#[KyberPreKeyRecord]generate()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/GenericSignedPreKey#new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/kyber_prekey/impl#[KyberPreKeyRecord]generate()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 timestamp/impl#[Timestamp]from_epoch_millis()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/kyber_prekey/impl#[KyberPreKeyRecord]generate()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[KeyPair]generate()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#Plaintext#" -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessage#SenderKeyMessage#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#Plaintext#" -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessage#PlaintextContent#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#Plaintext#" -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#Whisper#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#Plaintext#" -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessage#SignalMessage#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#Plaintext#" -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessage#PreKeySignalMessage#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#Plaintext#" -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#PreKey#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#Plaintext#" -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#SenderKey#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Key<T>`]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[KeyType][`TryFrom<u8>`]try_from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Key<T>`]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Ciphertext<'a>`]deserialize()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Key<T>`]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#BadKEMKeyLength#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Key<T>`]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`KeyMaterial<T>`]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Key<T>`]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#WrongKEMKeyType#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Key<T>`]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#NoKeyTypeIdentifier#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Key<T>`]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/KeyKind#key_length()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderKeyRecord]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidProtobufEncoding#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderKeyRecord]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderKeyState]from_protobuf()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderKeyRecord]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderKeyState]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/test/fingerprint_encodings()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/impl#[ScannableFingerprint]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Key<Secret>`][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Key<T>`]deserialize()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemPreKeyStore][Default]default()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemPreKeyStore]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemPreKeyStore][Default]default()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidPreKeyId#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/impl#[ChainKey]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/impl#[MessageKeyGenerator]new_from_seed()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/impl#[ChainKey]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/hmac_sha256()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/initialize_alice_session_record()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/initialize_alice_session()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/initialize_alice_session_record()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SessionRecord]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_pre_key_signal_message_serialize_deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[PreKeySignalMessage][`TryFrom<&[u8]>`]try_from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_pre_key_signal_message_serialize_deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[PreKeySignalMessage]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_pre_key_signal_message_serialize_deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/assert_signal_message_equals()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_pre_key_signal_message_serialize_deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/create_signal_message()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/decode_varint()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/advance()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/decode_varint()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidProtobufEncoding#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/decode_varint()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidSealedSenderMessage#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/tests/test_serialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/KeyType#Kyber1024#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/tests/test_serialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Key<T>`]deserialize()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[ServerCertificate]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidProtobufEncoding#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/impl#[`kem::Key<kem::Public>`][KeySerde]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Key<T>`]deserialize()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/impl#[`Incremental<M>`]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/hmac_sha256()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/group_encrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SenderKeyMessage]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/group_encrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#NoSenderKeyState#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/group_encrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidSenderKeySession#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt_to_usmc()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidSealedSenderMessage#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt_to_usmc()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v1/impl#[StaticKeys]calculate()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt_to_usmc()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/aes256_ctr_hmacsha256_decrypt()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt_to_usmc()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/DecryptionError#BadKeyOrIv#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt_to_usmc()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/apply_agreement_xor()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt_to_usmc()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/UnidentifiedSenderMessage#V2#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt_to_usmc()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/DecryptionError#BadCiphertext#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt_to_usmc()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/UnidentifiedSenderMessage#V1#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt_to_usmc()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/traits/Direction#Receiving#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt_to_usmc()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/impl#[DerivedKeys]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt_to_usmc()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[UnidentifiedSenderMessageContent]deserialize()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt_to_usmc()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/compute_authentication_tag()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt_to_usmc()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v1/impl#[EphemeralKeys]calculate()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt_to_usmc()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[`UnidentifiedSenderMessage<'a>`]deserialize()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/bundle/impl#[PreKeyBundle][`TryFrom<PreKeyBundleContent>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 state/bundle/impl#[PreKeyBundle]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/bundle/impl#[PreKeyBundle][`TryFrom<PreKeyBundleContent>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidArgument#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_chain_key_iteration_tests/iteration()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderChainKey]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SignalMessage]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SignalMessage]compute_mac()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v1/impl#[EphemeralKeys]calculate()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/traits/Direction#Sending#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v1/impl#[EphemeralKeys]calculate()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/traits/Direction#Receiving#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session/process_prekey_bundle()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/initialize_alice_session()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 session/process_prekey_bundle()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/params/impl#[AliceSignalProtocolParameters]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 session/process_prekey_bundle()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#UntrustedIdentity#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session/process_prekey_bundle()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/traits/Direction#Sending#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session/process_prekey_bundle()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SessionRecord]new_fresh()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 session/process_prekey_bundle()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#SignatureValidationFailed#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/GenericSignedPreKey#new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/GenericSignedPreKey#from_storage()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SenderKeyMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#LegacyCiphertextVersion#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SenderKeyMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#UnrecognizedCiphertextVersion#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SenderKeyMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#CiphertextMessageTooShort#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SenderKeyMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidProtobufEncoding#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/tests/test_serialize_identity_key_pair()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKeyPair]generate()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/tests/test_serialize_identity_key_pair()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKeyPair][`TryFrom<&[u8]>`]try_from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/kyber_prekey/impl#[KyberPreKeyRecord][GenericSignedPreKey]from_storage()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Key<T>`]deserialize()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SenderKeyDistributionMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#UnrecognizedCiphertextVersion#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SenderKeyDistributionMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidProtobufEncoding#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SenderKeyDistributionMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#LegacyCiphertextVersion#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SenderKeyDistributionMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#CiphertextMessageTooShort#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/add_second_state()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/random_public_key()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/add_second_state()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/chain_key()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/add_second_state()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/impl#[TestContext]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/add_single_state()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/random_public_key()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/add_single_state()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/chain_key()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/add_single_state()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/impl#[TestContext]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/derive_keys()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/derive_keys_with_label()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[`SealedSenderV2SentMessage<'a>`]parse()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#UnknownSealedSenderVersion#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[`SealedSenderV2SentMessage<'a>`]parse()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidSealedSenderMessage#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/Parameters#decapsulate()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/Parameters#encapsulate()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/Parameters#decapsulate()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/Parameters#generate()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/decrypt_message_with_record()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidMessage#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/decrypt_message_with_record()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/create_decryption_failure_log()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/decrypt_message_with_record()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/CurrentOrPrevious#Current#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/decrypt_message_with_record()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/CurrentOrPrevious#Previous#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/decrypt_message_with_record()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#DuplicatedMessage#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/decrypt_message_with_record()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#Whisper#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/decrypt_message_with_record()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#PreKey#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/decrypt_message_with_record()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/decrypt_message_with_state()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/new_incremental()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/impl#[`Incremental<M>`]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKey][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKey]decode()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/test/fingerprint_mismatching_identifiers()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKeyPair]generate()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/test/fingerprint_mismatching_identifiers()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/impl#[Fingerprint]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/test/fingerprint_mismatching_versions()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKey]decode()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/test/fingerprint_mismatching_versions()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/impl#[Fingerprint]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_decryption_error_message_for_plaintext()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidArgument#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_decryption_error_message_for_plaintext()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[DecryptionErrorMessage]for_original()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_decryption_error_message_for_plaintext()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#Plaintext#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_decryption_error_message_for_plaintext()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 timestamp/impl#[Timestamp]from_epoch_millis()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/aes256_ctr_hmacsha256_encrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/aes_256_ctr_encrypt()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/aes256_ctr_hmacsha256_encrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/hmac_sha256()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_decrypt_prekey()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/decrypt_message_with_record()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_decrypt_prekey()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 session/process_prekey()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_decrypt_prekey()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SessionRecord]new_fresh()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_decrypt_prekey()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/create_decryption_failure_log()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_decrypt_prekey()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#PreKey#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_multi_recipient_encrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_multi_recipient_encrypt_impl()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKeyPair][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKey][`TryFrom<&[u8]>`]try_from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKeyPair][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidProtobufEncoding#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SessionState]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKey]decode()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SessionState]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/impl#[ChainKey]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SessionState]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/impl#[RootKey]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SessionState]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/impl#[MessageKeyGenerator]from_pb()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SessionState]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[`UnacknowledgedPreKeyMessageItems<'a>`]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/extract_decryption_error_message_from_serialized_content()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[DecryptionErrorMessage][`TryFrom<&[u8]>`]try_from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/extract_decryption_error_message_from_serialized_content()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidArgument#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/extract_decryption_error_message_from_serialized_content()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidProtobufEncoding#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/get_sender_key()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidMessage#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/get_sender_key()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#DuplicatedMessage#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/get_sender_key()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#SenderKey#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 group_cipher/get_sender_key()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidSenderKeySession#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/test/fingerprint_test_v1()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKey]decode()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/test/fingerprint_test_v1()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/impl#[Fingerprint]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/aes_256_ctr_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/aes_256_ctr_encrypt()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/aes_256_ctr_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/EncryptionError#BadKeyOrIv#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/aes_256_ctr_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/DecryptionError#BadKeyOrIv#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/tests/test_chain_key_derivation()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/impl#[ChainKey]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidSealedSenderMessage#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_decrypt_signal()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidMessage#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[PreKeySignalMessage][`TryFrom<&[u8]>`]try_from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#Whisper#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#PreKey#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#SealedSenderSelfSend#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SignalMessage][`TryFrom<&[u8]>`]try_from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_decrypt_prekey()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_decrypt_to_usmc()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_encrypt_from_usmc()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/traits/Direction#Sending#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_encrypt_from_usmc()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v1/impl#[StaticKeys]calculate()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_encrypt_from_usmc()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#SessionNotFound#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_encrypt_from_usmc()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v1/impl#[EphemeralKeys]calculate()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_encrypt_from_usmc()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/aes256_ctr_hmacsha256_encrypt()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderKeyState]from_protobuf()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderChainKey]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderKeyState]from_protobuf()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderMessageKey]from_protobuf()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/when_second_state_with_different_public_key_but_same_chain_id_added_then_it_gets_replaced()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/chain_key()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/when_second_state_with_different_public_key_but_same_chain_id_added_then_it_gets_replaced()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/random_public_key()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/when_second_state_with_different_public_key_but_same_chain_id_added_then_it_gets_replaced()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/impl#[TestContext]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/compute_authentication_tag()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/traits/Direction#Sending#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/compute_authentication_tag()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/traits/Direction#Receiving#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[KeyPair]from_public_and_private()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#WrongKEMKeyType#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[KeyPair]from_public_and_private()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Key<Secret>`][`TryFrom<&[u8]>`]try_from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[KeyPair]from_public_and_private()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Key<Public>`][`TryFrom<&[u8]>`]try_from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[ContentHint][`From<u32>`]from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/ContentHint#Default#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[ContentHint][`From<u32>`]from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/ContentHint#Resendable#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[ContentHint][`From<u32>`]from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/ContentHint#Unknown#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[ContentHint][`From<u32>`]from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/ContentHint#Implicit#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSignalProtocolStore]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSessionStore]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSignalProtocolStore]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemIdentityKeyStore]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSignalProtocolStore]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemPreKeyStore]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSignalProtocolStore]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSenderKeyStore]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSignalProtocolStore]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSignedPreKeyStore]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSignalProtocolStore]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemKyberPreKeyStore]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 session/process_prekey_impl()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 session/impl#[PreKeysUsed][Default]default()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 session/process_prekey_impl()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/initialize_bob_session()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 session/process_prekey_impl()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/params/impl#[`BobSignalProtocolParameters<'a>`]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[PreKeySignalMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#CiphertextMessageTooShort#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[PreKeySignalMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#PreKey#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[PreKeySignalMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SignalMessage][`TryFrom<&[u8]>`]try_from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[PreKeySignalMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#UnrecognizedCiphertextVersion#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[PreKeySignalMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidMessage#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[PreKeySignalMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidProtobufEncoding#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[PreKeySignalMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKey][`TryFrom<&[u8]>`]try_from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[PreKeySignalMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[KyberPayload]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[PreKeySignalMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#LegacyCiphertextVersion#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/chunk_sizes_sha256()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/calculate_chunk_size()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderChainKey]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/hmac_sha256()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderChainKey]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidState#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderChainKey]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderMessageKey]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/impl#[`kem::KeyPair`][KeyPairSerde]from_public_and_private()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[KeyPair]from_public_and_private()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/chunk_size_zero()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/new_incremental()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/aes_256_ctr_encrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/EncryptionError#BadKeyOrIv#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[UnidentifiedSenderMessageContent]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[ProtoMessageType][`From<CiphertextMessageType>`]from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/aes256_ctr_hmacsha256_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/aes_256_ctr_decrypt()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/aes256_ctr_hmacsha256_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/hmac_sha256()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/aes256_ctr_hmacsha256_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/DecryptionError#BadCiphertext#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/when_second_state_with_same_public_key_and_chain_id_added_then_it_becomes_the_most_recent()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/impl#[TestContext]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/when_second_state_with_same_public_key_and_chain_id_added_then_it_becomes_the_most_recent()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/chain_key()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/when_second_state_with_same_public_key_and_chain_id_added_then_it_becomes_the_most_recent()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/random_public_key()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/test_lossless_round_trip()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 timestamp/impl#[Timestamp]from_epoch_millis()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/test_lossless_round_trip()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[SenderCertificate]deserialize()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SignalProtocolError][`From<InvalidSessionError>`]from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidSessionStructure#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/impl#[MessageKeyGenerator]new_from_seed()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/MessageKeyGenerator#Keys#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/impl#[MessageKeyGenerator]new_from_seed()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/impl#[MessageKeys]derive_keys()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/impl#[MessageKeyGenerator]new_from_seed()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/MessageKeyGenerator#Seed#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/total_digest_size()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/calculate_chunk_size()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_signal_message_serialize_deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/create_signal_message()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_signal_message_serialize_deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SignalMessage][`TryFrom<&[u8]>`]try_from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_signal_message_serialize_deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/assert_signal_message_equals()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSignedPreKeyStore][Default]default()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSignedPreKeyStore]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSignedPreKeyStore][Default]default()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidSignedPreKeyId#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[`UnidentifiedSenderMessage<'a>`]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#UnknownSealedSenderVersion#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[`UnidentifiedSenderMessage<'a>`]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidProtobufEncoding#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[`UnidentifiedSenderMessage<'a>`]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/UnidentifiedSenderMessage#V2#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[`UnidentifiedSenderMessage<'a>`]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidSealedSenderMessage#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[`UnidentifiedSenderMessage<'a>`]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/UnidentifiedSenderMessage#V1#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/create_signal_message()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SignalMessage]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/prekey/impl#[PreKeyRecord]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidProtobufEncoding#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_decrypt_signal()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/traits/Direction#Receiving#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_decrypt_signal()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#UntrustedIdentity#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_decrypt_signal()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#Whisper#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_decrypt_signal()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/decrypt_message_with_record()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_decrypt_signal()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#SessionNotFound#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_encrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidSessionStructure#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_encrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/traits/Direction#Sending#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_encrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#SessionNotFound#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_encrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessage#PreKeySignalMessage#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_encrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidState#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_encrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[KyberPayload]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_encrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessage#SignalMessage#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_encrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#UntrustedIdentity#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_encrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SignalMessage]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_encrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[PreKeySignalMessage]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[CiphertextMessageType][`From<ProtoMessageType>`]from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#SenderKey#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[CiphertextMessageType][`From<ProtoMessageType>`]from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#Whisper#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[CiphertextMessageType][`From<ProtoMessageType>`]from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#PreKey#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[CiphertextMessageType][`From<ProtoMessageType>`]from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#Plaintext#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/kyber768/impl#[Parameters][Parameters]generate()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`KeyMaterial<T>`]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/initialize_bob_session_record()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SessionRecord]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/initialize_bob_session_record()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/initialize_bob_session()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/impl#[Fingerprint]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/impl#[ScannableFingerprint]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/impl#[Fingerprint]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/impl#[DisplayableFingerprint]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/impl#[Fingerprint]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/impl#[Fingerprint]get_fingerprint()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_sender_key_message_serialize_deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SenderKeyMessage]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_sender_key_message_serialize_deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SenderKeyMessage][`TryFrom<&[u8]>`]try_from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_decryption_error_message()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#PreKey#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_decryption_error_message()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SenderKeyMessage]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_decryption_error_message()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#SenderKey#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_decryption_error_message()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[PreKeySignalMessage]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_decryption_error_message()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#Whisper#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_decryption_error_message()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/create_signal_message()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_decryption_error_message()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 timestamp/impl#[Timestamp]from_epoch_millis()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_decryption_error_message()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[DecryptionErrorMessage]for_original()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/tests/test_decryption_error_message()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[DecryptionErrorMessage][`TryFrom<&[u8]>`]try_from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[SenderCertificate]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 timestamp/impl#[Timestamp]from_epoch_millis()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[SenderCertificate]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidProtobufEncoding#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[SenderCertificate]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[ServerCertificate]deserialize()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/tests/test_kyber1024_keypair()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/KeyType#Kyber1024#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/tests/test_kyber1024_keypair()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[KeyPair]generate()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Ciphertext<'a>`]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[KeyType][`TryFrom<u8>`]try_from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Ciphertext<'a>`]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#BadKEMCiphertextLength#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Ciphertext<'a>`]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#NoKeyTypeIdentifier#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderKeyState]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderChainKey]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/advance()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidProtobufEncoding#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/validating_simple_test()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/new_incremental()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/tests/test_kyber1024_kem()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Key<T>`]deserialize()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/tests/test_kyber1024_kem()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/KeyType#Kyber1024#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_multi_recipient_encrypt_impl()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/impl#[DerivedKeys]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_multi_recipient_encrypt_impl()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidRegistrationId#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_multi_recipient_encrypt_impl()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/apply_agreement_xor()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_multi_recipient_encrypt_impl()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/traits/Direction#Sending#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_multi_recipient_encrypt_impl()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidArgument#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_multi_recipient_encrypt_impl()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/compute_authentication_tag()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_multi_recipient_encrypt_impl()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#SessionNotFound#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_multi_recipient_encrypt_impl()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidState#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/kyber1024/impl#[Parameters][Parameters]generate()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`KeyMaterial<T>`]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/impl#[TestContext]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderKeyRecord]new_empty()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/simple_test()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 crypto/hmac_sha256()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/simple_test()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/new_incremental()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/validating_returns_right_size()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 incremental_mac/test/new_incremental()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/test/fingerprint_test_v2()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/impl#[Fingerprint]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/test/fingerprint_test_v2()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKey]decode()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[DecryptionErrorMessage]for_original()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[PreKeySignalMessage][`TryFrom<&[u8]>`]try_from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[DecryptionErrorMessage]for_original()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#Plaintext#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[DecryptionErrorMessage]for_original()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#SenderKey#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[DecryptionErrorMessage]for_original()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidArgument#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[DecryptionErrorMessage]for_original()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#Whisper#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[DecryptionErrorMessage]for_original()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SignalMessage][`TryFrom<&[u8]>`]try_from()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[DecryptionErrorMessage]for_original()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#PreKey#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[DecryptionErrorMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidProtobufEncoding#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[DecryptionErrorMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 timestamp/impl#[Timestamp]from_epoch_millis()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/initialize_bob_session()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/derive_keys()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/initialize_bob_session()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/message_version()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/initialize_bob_session()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SessionState]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SignalMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidProtobufEncoding#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SignalMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#UnrecognizedCiphertextVersion#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SignalMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#LegacyCiphertextVersion#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SignalMessage][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#CiphertextMessageTooShort#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Key<Public>`][`TryFrom<&[u8]>`]try_from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Key<T>`]deserialize()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/initialize_alice_session()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/derive_keys()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/initialize_alice_session()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SessionState]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/initialize_alice_session()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/message_version()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/when_exceed_maximum_states_then_oldest_is_ejected()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/chain_key()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/when_exceed_maximum_states_then_oldest_is_ejected()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/impl#[TestContext]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/when_exceed_maximum_states_then_oldest_is_ejected()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/random_public_key()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/impl#[MessageKeyGenerator]from_pb()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/MessageKeyGenerator#Keys#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/impl#[MessageKeyGenerator]from_pb()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 ratchet/keys/MessageKeyGenerator#Seed#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/signed_prekey/impl#[`kem::Key<kem::Secret>`][KeySerde]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 kem/impl#[`Key<T>`]deserialize()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/impl#[SignalMessage]compute_mac()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidMacKeyLength#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[ProtoMessageType][`From<CiphertextMessageType>`]from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#Plaintext#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[ProtoMessageType][`From<CiphertextMessageType>`]from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#Whisper#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[ProtoMessageType][`From<CiphertextMessageType>`]from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#SenderKey#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[ProtoMessageType][`From<CiphertextMessageType>`]from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessageType#PreKey#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 state/session/impl#[SessionRecord]deserialize()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidState#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderMessageKey]from_protobuf()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderMessageKey]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/apply_agreement_xor()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/traits/Direction#Receiving#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_v2/apply_agreement_xor()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 storage/traits/Direction#Sending#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 storage/inmem/impl#[InMemSessionStore]new()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#SessionNotFound#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidArgument#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_decrypt_prekey()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessage#PreKeySignalMessage#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 protocol/CiphertextMessage#SignalMessage#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_decrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_decrypt_signal()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/get_or_create_message_key()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#DuplicatedMessage#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/get_or_create_message_key()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidMessage#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/when_second_state_with_same_public_key_and_chain_id_added_then_it_keeps_first_data()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/impl#[TestContext]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/when_second_state_with_same_public_key_and_chain_id_added_then_it_keeps_first_data()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/random_public_key()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/when_second_state_with_same_public_key_and_chain_id_added_then_it_keeps_first_data()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_key_record_add_sender_key_state_tests/chain_key()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 error/impl#[SignalProtocolError][`From<CurveError>`]from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#NoKeyTypeIdentifier#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 error/impl#[SignalProtocolError][`From<CurveError>`]from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#BadKeyLength#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 error/impl#[SignalProtocolError][`From<CurveError>`]from()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#BadKeyType#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/test/fingerprint_mismatching_fingerprints()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 identity_key/impl#[IdentityKeyPair]generate()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/test/fingerprint_mismatching_fingerprints()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 fingerprint/impl#[Fingerprint]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_chain_key_iteration_tests/when_sender_chain_key_iteration_overflows()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/impl#[SenderChainKey]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sender_keys/sender_chain_key_iteration_tests/when_sender_chain_key_iteration_overflows()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 error/SignalProtocolError#InvalidState#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_encrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 session_cipher/message_encrypt()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_encrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/impl#[UnidentifiedSenderMessageContent]new()."
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_encrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/ContentHint#Default#"
  "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_encrypt()." -> "rust-analyzer cargo libsignal-protocol 0.1.0 sealed_sender/sealed_sender_encrypt_from_usmc()."
}
